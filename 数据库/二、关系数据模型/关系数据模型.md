
# 关系数据模型

​	首先，关系数据模型是一种数据模型。因此，也分为三部分。

> 顾名思义，关系数据模型的 **数据结构** 为 **关系** ——一个二维表格
>
> **数据操纵** ：增删改查
>
> **完整性**：实体完整性、参照完整性、用户自定义完整性。

## 1.关系

​	**关系** 是一个有行和列的表格，仅适用于数据库的逻辑结构。

> **属性** 是关系的一个列名
>
> **域** 是一个属性或者多个属性允许赋值的集合。
>
> **元组** 是一个关系的一行数据。
>
> **度** 是一个关系中属性的个数，即列名的个数。
>
> **基数** 是关系中元组的个数。

​	**关系数据库是一个具有不同名称的规范化关系的集合**. 每一个关系的名称必须是惟一的。

举个栗子：

​								**Student**

| Sno   | Sname | age  | Sex  | dept |
| ----- | ----- | ---- | ---- | ---- |
| 11111 | 张三  | 19   | 男   | 软件 |
| 11112 | 李四  | 18   | 男   | 经管 |
| ...   | ...   | ...  | ...  | ...  |
| 12000 | 王薇  | 18   | 女   | 经管 |

属性为：Sno，Sname，Age，Sex，Dept

度为5、元组个数为100，关系名为Student，元组为关系中的每一行，age的域为假设为【15,45】（即允许取值的范围）。

---

***等价描述***（每一行的叙述是等价的）

| 关系 | 表   | 文件 |
| ---- | ---- | ---- |
| 元组 | 行   | 记录 |
| 属性 | 列   | 域   |

---

**关系的特点**

> 表名彼此不同，并且唯一
>
> 每一个表中的元素都是原子，简言之不允许表中有表
>
> 每一个属性都有一个惟一的名字
>
> 每一个属性的值来自一个相同的域
>
> 每一个元祖都是不同的，不会有重复的元组在表中出现
>
> 属性的顺序可以任意。元组的顺序也可以任意（但是在效率上可能有不一样）

## 2.值和型

> 关系模式：由一组属性和域名对定义的命名关系。eg：student（sno，sname，DOB）

关系模式是 **型** ，关系是 **值** 。

也就是说，**关系是一个表格，而关系模式是 表头（定义）＋表名**

---

> 关系数据库模式：关系模式的集合，每个关系模式的名字都是惟一的。

关系数据库模式是 **型** ，关系数据库是 **值** 。

也就是说，**关系数据库模式是数据库的定义，每个关系数据库是具体的数据。**

---

举个例子：以图书馆为例

一个空的书架： ***关系模式*** 

书架上每一行的标签： ***属性名***

一个图书馆只有若干空的书架： ***关系数据库模式***

一个暑假装满书： **关系**

一个图书馆有若干装满书的书架：***关系数据库***

## 3.关键字

> **超键** ：一个能够唯一确定一行元组的属性或者属性组。
>
> **候选键**（CK）：超键中能够唯一识别一行元组的属性组且其真子集不能唯一识别一行元组。简言之，超键中能够用最少属性唯一确定一个元组的为候选键。**（一个关系中可能有多个候选键）**
>
> **主键** （PK）：从候选键中选出一个作为主键。**（一个关系中只有一个主键）**
>
> **备用键**（AK）：候选键中没被选择的键作为候选键。 其中 **PK + AK = CK**
>
> **主属性** ：所有候选码中的属性都是主属性。
>
> **外键** ：参照其他表的属性。
>
> **null**：表示当前属性是未知的或者不合适的，不能用0或者空格代替。

## 4.关系完整性

> **实体完整性**：能唯一识别一行元组的属性不能为null **（尤其主键属性不能为空）**
>
> **参照完整性**：如果关系中存在外键，要么外键匹配参照表的一个候选键（不一定是主键），要么为null。其中，外键的名称不必须和该表中属性名相同。
>
> **用户自定义的完整性**：由用户根据实际需要自己定义的完整性。比如：教授的工资不会低于副教授的工资等。

## 5.关系代数

简言之，关系代数就是在关系上的运算，即 ”关系运算“，并且不会改变原来的关系。

> **五种基本运算**
>
> > 选择、投影、并、笛卡尔积、差
>
> **三种特殊运算**（可以由五种基本运算导出）
>
> > 连接、交、除

## 5.1 选择（限制）

$$
\sigma_{条件p}(R):在关系R中查找满足条件p的所有元组 \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad
$$

举个栗子：

$$
\sigma_{salary > 10000}(Staff)意为：在staff表中查找工资大于10000的员工。\qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad
$$

$$
条件也可以通过逻辑运算符 \land(AND) ,\lor(OR),\lnot(Not)，=(Equal)来进行条件运算\qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad
$$

$$
\sigma_{(salary > 10000) \land (age < 50)}(Staff)意为：在Staff表中查找年龄小于50岁且工资大于10000的员工。\qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad
$$

# 5.2 投影

$$
\prod {_{col1,col2,col3...coln}}(R):在关系R中返回指定列col1...coln的所有元组，并消除重复行。
$$

举个栗子：

$$
\prod{_{salary,age}}(Staff)意为：在Staff表中返回指定两列工资和年龄的所有信息，其他信息都不显示，并且如果有两行元组相同，消除重复行。
$$

# 5.3 并

## 5.3.1 并相容

​	如果两个模式，其中相对应的数据项的数据个数和数据定义都相同，我们认为两个关系是并相容的。（对应数据项的名称可以不同）

举个栗子：

S_1( s_no : char(8) , s_name : char(20) , age : smallint)

S_2( s_no : char(10), s_name : char(20) , age: smallint )

我们可以看到，S_1和S_2中的s_no的数据定义类型不同，因此，S_1和S_2非并相容。

S_1( s_no : char(8) , s_name : char(20) , age : smallint)

S_2( s_no : char(8), s_name : char(20) , age: smallint ，sex : char(2))

我们可以看到，S_1和S_2中的数据项个数不同，S_2多了一项sex，因此S_1和S_2非并相容。

S_1( s_no : char(8) , s_name : char(20) , age : smallint)

S_2( StudentNo : char(8), s_name : char(20) , age: smallint )

我们可以看到，对于每一个对应的数据项，他们的数据定义都相同，并且数据项的个数相同。那么，他们是并相容的，虽然他们变量名不一致。

## 5.3.2 并操作

> 如果两个模式是并相容的，那么将他们的元组拼接到一起，并消除重复的元组。

$$
R \cup S意为：关系R上的元组并上关系S上的元组。并且消除重复的元组。
$$

举个栗子：

关系R:

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  1   |  2   |  3   |
|  4   |  5   |  6   |
|  7   |  8   |  9   |

关系S:

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  4   |  5   |  6   |
|  1   |  12  |  4   |
|  4   |  5   |  3   |

那么，R ∪ S 的结果为（R和S中都有（4,5,6），因此删除一个）

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  1   |  2   |  3   |
|  4   |  5   |  6   |
|  7   |  8   |  9   |
|  1   |  12  |  4   |
|  4   |  5   |  3   |

> tips:
>
> > **通常，两个关系是不相容的，但是为了使两个关系成为并相容关系，我们会使用投影操作。**
> >
> > 举个栗子：
> > 
> > $$
> > \prod{_{city}}(Branch) \cup \prod{_{city}}(Property)
> > $$
> > 

# 5.4 差

$$
R_1 - R_2 意为：在关系R_1中删去在集合R_2中出现的元组。(前提：R_1和R_2都是并相容的)
$$

举个栗子：

关系R:

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  1   |  2   |  3   |
|  4   |  5   |  6   |
|  7   |  8   |  9   |

关系S:

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  4   |  5   |  6   |
|  1   |  12  |  4   |
|  4   |  5   |  3   |

那么，R  -  S 的结果为（删去了R中的（4,5,6）这个元组）

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  1   |  2   |  3   |
|  7   |  8   |  9   |

> tips：
>
> > 参考关系的并操作，关系的差操作通常也需要用到投影操作来使得两个关系是并相容的。

# 5.5 交

$$
	R \cap S 意为：找关系R和关系S中共有的元组。(前提：关系R和关系S是并相容的)
$$

举个栗子：

关系R:

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  1   |  2   |  3   |
|  4   |  5   |  6   |
|  7   |  8   |  9   |

关系S:

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  4   |  5   |  6   |
|  1   |  12  |  4   |
|  4   |  5   |  3   |

那么，R  ∩  S 的结果为（因为关系R和关系S中都有（4,5,6））

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  4   |  5   |  6   |

> tips：
>
> > 参考关系的并和差操作，关系的交操作通常也需要用到投影操作来使得两个关系是并相容的。

# 5.6 笛卡尔积

$$
R × S ：如果R有m个元组，n个属性，S有p个元组，q个属性。那么笛卡尔积之后的结果有(m*p)个元组，(n+q)个属性。\\
如果两个关系中有重名属性，为了加以区分，需要加上关系名，即(关系名.属性)\qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad
$$

举个栗子：

关系R:

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  1   |  2   |  3   |
|  4   |  5   |  6   |
|  7   |  8   |  9   |

关系S:

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  4   |  5   |  6   |
|  1   |  12  |  4   |
|  4   |  5   |  3   |

那么，R  ×  S 的结果为

| R.A  | R.B  | R.C  | S.A  | S.B  | S.C  |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  2   |  3   |  4   |  5   |  6   |
|  1   |  2   |  3   |  4   |  5   |  6   |
|  1   |  2   |  3   |  5   |  6   |  7   |
|  4   |  5   |  6   |  1   |  12  |  4   |
|  4   |  5   |  6   |  1   |  12  |  4   |
|  4   |  5   |  6   |  1   |  12  |  4   |
|  7   |  8   |  9   |  4   |  5   |  3   |
|  7   |  8   |  9   |  4   |  5   |  3   |
|  7   |  8   |  9   |  4   |  5   |  3   |

# 5.7 连接

> **连接** 操作可以由 **笛卡尔积** 和 **选择** 操作复合

## 5.7.1 θ连接

$$
R \Join_F S 意为：\sigma_F(R×S)，其中F是比较运算符R.a_i \theta(<,\le ,>,\ge,=,\ne)S.b_i
$$

## 5.7.2 等值连接

$$
当\theta连接中的比较运算符为=的时候，\theta连接为等值连接。
$$

> 等值连接不一定在公共属性上做，可以在任意两个属性上做

举个栗子：

关系R:

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  1   |  2   |  3   |
|  4   |  5   |  6   |
|  7   |  8   |  9   |

关系S:

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  4   |  5   |  6   |
|  1   |  12  |  4   |
|  4   |  5   |  3   |

$$
求：关系R\Join_{2<1} S
$$

| R.A  | R.B  | R.C  | S.A  | S.B  | S.C  |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  2   |  3   |  4   |  5   |  6   |
|  1   |  2   |  3   |  4   |  5   |  3   |

$$
求：关系 R \Join_{1 = 1}S
$$

| R.A  | **R.B** | R.C  | S.A  | S.B  | S.C  |
| :--: | :-----: | :--: | :--: | :--: | :--: |
|  1   |    2    |  3   |  1   |  12  |  4   |
|  4   |    5    |  6   |  4   |  5   |  6   |
|  4   |    5    |  6   |  4   |  5   |  3   |

## 5.7.3 自然连接

$$
R \Join S意为：在两个关系R和S的公共属性上做连接，并消除一个重复属性。如果没有公共属性，那么转换为笛卡尔积。
$$

举个栗子：

关系R：

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  a1  |  b1  |  5   |
|  a1  |  b2  |  6   |
|  a2  |  b3  |  8   |
|  a2  |  b4  |  12  |

关系S

|  B   |  E   |
| :--: | :--: |
|  b1  |  3   |
|  b2  |  7   |
|  b3  |  10  |
|  b3  |  2   |
|  b5  |  2   |

$$
求关系 R\Join_{2=2} S 
$$

|  A   | R.B  |  C   | S.B  |  E   |
| :--: | :--: | :--: | :--: | :--: |
|  a1  |  b1  |  5   |  b1  |  2   |
|  a1  |  b2  |  6   |  b2  |  7   |
|  a2  |  b3  |  8   |  b3  |  10  |
|  a2  |  b3  |  8   |  b3  |  3   |

$$
求关系R\Join S
$$

|  A   |  B   |  C   |  E   |
| :--: | :--: | :--: | :--: |
|  a1  |  b1  |  5   |  2   |
|  a1  |  b2  |  6   |  7   |
|  a2  |  b3  |  8   |  10  |
|  a2  |  b3  |  8   |  3   |

> $$
> \color{red}两个关系分别做自然连接和等值连接之后的度(属性个数) 和基数(元组个数) 都不一定相同。
> $$

## 5.7.4 外连接

​	在两个关系自然连接的时候，我们发现，没有公共属性的时候，关系中的元组不会显示出来，这样的元组我们称为 **悬浮元组** 。为了保留悬浮元组，我们引入了外连接。

> 左外连接：保留左边关系R中的悬浮元组
>
> 右外连接：保留右边关系S中的悬浮元组
>
> 全外连接：保留关系R和S中的全部悬浮元组

$$
R\rtimes S意为：左外连接
$$

$$
R\ltimes S意为：右外连接
$$

$$
\newcommand{\FullOuterJoin}{\text{⟗}}
$$

$$
R \FullOuterJoin S意为：全外连接
$$

举个栗子：

关系R：

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  a   |  b   |  c   |
|  b   |  b   |  f   |
|  c   |  a   |  d   |

关系S：

|  B   |  C   |  D   |
| :--: | :--: | :--: |
|  b   |  c   |  d   |
|  b   |  c   |  e   |
|  a   |  d   |  b   |
|  3   |  f   |  g   |

$$
则 R \rtimes S 为
$$

|  A   |  B   |  C   |  D   |
| :--: | :--: | :--: | :--: |
|  a   |  b   |  c   |  d   |
|  a   |  b   |  c   |  e   |
|  c   |  a   |  d   |  b   |
|  b   |  b   |  f   | null |

$$
则R\ltimes S为
$$

|  A   |  B   |  C   |  D   |
| :--: | :--: | :--: | :--: |
|  a   |  b   |  c   |  d   |
|  a   |  b   |  c   |  e   |
|  c   |  a   |  d   |  b   |
| null |  e   |  f   |  g   |

$$
则 R\FullOuterJoin S 为
$$

|  A   |  B   |  C   |  D   |
| :--: | :--: | :--: | :--: |
|  a   |  b   |  c   |  d   |
|  a   |  b   |  c   |  e   |
|  c   |  a   |  d   |  b   |
| null |  e   |  f   |  g   |
|  b   |  b   |  f   | null |

## 5.7.5 半连接

​	在自然连接的基础上，保留某一个关系的元素。

$$
eg: R 左半连接 S = \prod{_A}(R \Join_F B)
$$

举个栗子：

关系R：

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  a   |  b   |  c   |
|  b   |  b   |  f   |
|  c   |  a   |  d   |

关系S：

|  B   |  C   |  D   |
| :--: | :--: | :--: |
|  b   |  c   |  d   |
|  b   |  c   |  e   |
|  a   |  d   |  b   |
|  3   |  f   |  g   |

则R左半连接S为：

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  a   |  b   |  c   |
|  c   |  a   |  d   |

R右半连接S为：

|  B   |  C   |  D   |
| :--: | :--: | :--: |
|  b   |  c   |  d   |
|  b   |  c   |  e   |
|  a   |  d   |  b   |

# 5.8 除法

$$
R÷S定义为：假设R(X,Y),S(Y,Z),其中X，Y，Z都是属性组。因此，结果集就是在X中找到一个x_i,s使得x_i的像集为S。
$$

$$
返回所有这样的由x_i组成的元组。\qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad
$$

举个栗子：

R(X,Y) 假设X为（A），Y为（B，C）

|  A   |  B   |  C   |
| :--: | :--: | :--: |
|  a1  |  b1  |  c2  |
|  a2  |  b3  |  c7  |
|  a3  |  b4  |  c6  |
|  a1  |  b2  |  c3  |
|  a4  |  b6  |  c6  |
|  a2  |  b2  |  c3  |
|  a1  |  b2  |  c1  |

S(Y,Z) 假设Y为（B,C） Z为（D）

|  B   |  C   |  D   |
| :--: | :--: | :--: |
|  b1  |  c2  |  d1  |
|  b2  |  c1  |  d1  |
|  b2  |  c3  |  d2  |

因此，R ÷ S 等于

|  A   |
| :--: |
|  a1  |



> **除法往往用于在R中查找所有S中元素的时候。** 比如查找选修了所有课程的学生的信息。

