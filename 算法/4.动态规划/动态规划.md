$$
\color{red}说明：下述题目分析中用到的题目和图片均来自刘铎老师的PPT，仅供个人学习使用
$$


# 动态规划

​  &nbsp;&nbsp;在介绍动态规划之前，我们首先要说明一个问题。 ***递归和迭代的优缺点***  来为了下面使用动态规划算法做铺垫。

> 递归

​&nbsp;&nbsp;	首先，我们在分治的时候已经接触过递归算法了。在程序设计中， ***若一个函数在其函数体内又直接调用了自身，则称之为递归函数。*** 递归函数的特性就是：问题和子问题具有相同的结构、子问题的规模逐渐递减、有终止条件作为出口。这是一种 **自上而下** 的计算方式。

> 迭代

​&nbsp;&nbsp;	迭代法是一种不断用已经计算过的值来计算新的值的过程，它是一种 **自下而上** 的计算方式。

---

​	&nbsp;&nbsp;我们来看一个例子，斐波那契数列。它具有以下递推关系：

$$
F(n) = F(n-1) + F(n-2)
$$

​&nbsp;&nbsp;	其中F(1) = 1 , F(2) = 1 , 定义了如下序列 1,1,2,3,5,8...，因此我们可以得到如下两种算法

***递归算法*** 

```
Algorithm F(n)
if(n <= 2) then
	return 1
else
	return F(n-1) + F(n-2)
```

***迭代算法***

```
Algorithm F(n)
F[1] = 1 , F[2] = 1
for i = 3 to n
	F[i] = F[i-1] + F[i-2]
return F[n]
```

​&nbsp;&nbsp;	于是，我们可以看到，在递归算法，一旦n非常大，那么会有非常多的（***往往是指数阶***）的重复运算，比如我要算F(100)我要计算F(99)+F(98),然后再递归调用F(99)，那么就要计算F(98)+F(97)...，每次都含有大量的重复计算，因此会非常耗时间***（往往是我们无法接受的）***，这也是自上而下计算的缺点所在。

​&nbsp;&nbsp;	而迭代算法，是一种自下而上的运算方式。他从下开始往上填表，在填写新的值的时候可以直接用已经填好的数字进行计算，而不是再重复计算一次。比如同样计算F(100),在我计算F（100）的时候，其中前99项已经计算完成了，我只需要将两个数加起来（O(1)时间）就完成，因此时间是非常短的。

---

​	&nbsp;&nbsp;那么有小伙伴可能会有疑问了？为什么分治算法的时候，我们都是使用递归算法，但是不会产生这种时间爆炸的现象呢？

​&nbsp;&nbsp;	这是因为，我们分治算法的核心策略是将问题转化为具有相同问题模式的规模减小的子问题，其中每次都会舍弃一部分数据，不会有重复计算的过程。比如二分查找，每次舍弃一半数据，在剩下的数据中进行查找，不会再访问前半部分；比如归并排序，每次分成两半，在对应的一半再进行递归调用，不会重复计算。……

​&nbsp;&nbsp;	因此，***在分治算法中，我们多采用递归方式；而在接下来介绍的动态规划中，我们多采用迭代的方式。***

​	

# 一、找零问题

> 问题描述：给定数值 n 和 m 种硬币的面值 d_1 , d_2 , ... , d_m ，设计一种方法，能够用最少数量硬币凑出总和 n 。

&nbsp;&nbsp;​	在解决这个问题之前，我们先举一个简单的例子，在之前贪婪策略的时候，我们曾经举过这样一个例子，我们这里沿用该例子。给定数值 19 和 4 种面值为1元、5元、7元、10元的硬币，如何用最少的硬币数量向顾客支付19元。

&nbsp;&nbsp;​	我们知道，此时贪婪算法失效。那么我们换一种策略来思考问题。不论我们找给顾客哪一枚硬币，我们总要给顾客一枚的，那么我们可以分成以下几种情况。

> 给顾客一枚1元硬币，之后按最优方式找给顾客18元
>
> 给顾客一枚5元硬币，之后按最优方式找给顾客14元
>
> 给顾客一枚7元硬币，之后按最优方式找给顾客12元
>
> 给顾客一枚10元硬币，之后按最优方式找给顾客9元

​&nbsp;&nbsp;	我们发现，无外乎就这四种情况，我们能够知道每一个求解方式的 “由来” ，但是不知道是由哪个解构成的最优解。那么我们完全可以分别计算这四个值，哪个值最小，我们取哪个值。
&nbsp;&nbsp;​	于是，我们就成功的应用了动态规划的思想。在该问题中，每一个n值都可能有多个解，我们希望找到一个最优解，我们知道解的构成，但是不知道哪个解是最优解，于是利用 ***状态转移方程*** 来不断计算最优解，以达到我们的目的。

​&nbsp;&nbsp;	于是，对于该问题，我们得到一个递推式：

$$
令d(i)表示凑出i元所需的最少硬币数量。初始值d(0)=0,d(i)= \infty \quad (i \neq 0)
$$

$$
于是d(i) = min\{ d(i-d_k)\}+1 \quad 其中(k=1,2,...,m \quad i \ge d_k)
$$

​&nbsp;&nbsp;	也就是说，对于d(12)来说，d(12) = min { d(2) , d(5) , d(7) , d(11) } + 1。我们在计算的时候，把每个解都填在表中，在后续填表的时候只需要到表的对应位置去取值就可以。这也就是动态规划又叫  ***填表法***  的由来。

​&nbsp;&nbsp;	***我们一定要保证填在表中的每一个值都是最优解的值，并且初值很重要*** ， 一旦初值错误，那么后续所有的填表可能都是错的。

![1](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/1.png)

​	&nbsp;&nbsp;于是，对于面值为1、5、7、10的伪代码如下：

```
Find(n)
1.	find[0] = 0
2.	if i < 0 then find[i] = ∞
3.	for i = 1 to n
4.		find[i] = min {find[i-1] , find[i-5] , find[i-7] , find[i-10]} + 1
5.	return find[n]
```

​&nbsp;&nbsp;	对于其他面值的硬币，只需要将第4行伪代码中的 find[ i - d_k ] 进行变化即可。

# 二、最长单调递增子序列

​&nbsp;&nbsp;​	***子序列定义***：序列S的子序列是从S中删除零项或者多项并保持其余项的原有次序得到的。

> 例如：pred，sdn，predent都是 “president”的子序列
>
> > 子序列不同于子串，子串是连续的。比如pre，sident为子串。

$$
\color{red}{单调定义}\color{black}:给定数值x_1,x_2,...,x_n构成的序列S，若其子序x_{i_1},x_{i_2},...,x_{i_k}(i_{j+1} > i_{j})对所有的j都满足x_{i_{j+1}}>x_{i_j},称该子序列单调 \qquad \qquad \qquad \qquad \qquad 
$$

> 问题描述：希望找到S的一个最长单调子序列（LCS），可能不唯一。但是LCS的长度是惟一的。

​&nbsp;&nbsp;​	首先，我们举个例子，比如序列	1 , 8 , 2 , 9 , 3 , 10 , 4 , 5

​&nbsp;&nbsp;​	我们可以知道，1,2,3,4,5和1,8,9,10都是他的单调递增子序列，其中1,2,3,4,5是最长的。最短的单调子序列长度为1，即仅仅包含某个元素自己。于是，***最长单调子序列必定存在，且长度至少为1***。

---

算法思路：

1.令S[1]S[2]S[3]...S[n]表示输入序列

2.令L[i] (1 <=  i <= n)表示以S[i]结束的最长单调子序列长度。即只需要考虑前i项的最长单调子序列长度即可。

3.总目标为max{L[1],L[2],...L[n]}

----

​&nbsp;&nbsp;举个例子：S = 1 ， 8 ， 2 ， 9 ， 3 ， 10

​&nbsp;&nbsp;那么L[6] = max { L [1] , L [2] , L[3] , L[4] , L[5] } + 1  (为什么呢，因为S[6]=10比S[1]...S[5]都大，因此如果前i项中最大的单调递增子序列长度为a，那么这六项的最大单调递增子序列长度为a+1)

​&nbsp;&nbsp;那么 ***L[5] = max{ L [1] , L [2] , L[3] , L[4]  } + 1 ?***  显然是不对的。因为S[5]=3，而S[4]=9,也就是说，该LCS的长度一定是前4项中最长的LCS长度加一。比如，我们可以发现L[4]=3,那么L[5] = 3并不等于L[4] + 1。因此，正确的 ***L[5] = max { L[1] , L[3] } + 1***  。也就是说，***L[i]取决于前 i 项中S[i] > S[j] 的 max{ L[j] }( 1 <= j < i)***

​&nbsp;&nbsp;于是我们可以得到如下递推式：

$$
L[i] = 
\begin{cases}
max \{L[j] \} + 1 && 若存在j使得1\le j < i 且S[j] < S[i] \\
1 && else
\end{cases}
$$

伪代码如下：

```
输入：序列S[1]S[2]S[3]...S[n]
输出：输入序列的最长单调递增子序列的长度len
1.	for i = 1 to n do
2.		L[i] = 1
3.		for j = 1 to i-1 do
4.			if S[j] < S[i] and L[j] >= L[i] then
5.				L[i] = L[j] + 1
6.	len = max{L[1],L[2],...,L[n]}
```

​&nbsp;&nbsp;但是，现在我们不是要找LCS的长度，而是要找一个最长的一个LCS，也就是说LCS是由那几个元素组成的，因此，我们需要一个标记函数来进行回溯解的组成。

​&nbsp;&nbsp;因此，令 ***标记函数P[i]表示这个最长单调子序列中在S[i]之前一项的位置***  也就是记录 L[i] 到底是由哪一个 L[j] 得到的，记录这个 j 的 值。如果 L[i] = 1，则取 P[i] = 0。

于是伪代码为：

```
1.	for i = 1 to n do
2.		L[i] = 1 , P[i] = 0
3.		for j = 1 to i-1 do
4.			if S[j] < S[i] and L[j] >= L[i] then
5.				L[i] = L[j] + 1 , P[i] = j
6.	len = max{L[1],L[2],...,L[n]} // 假设最大值在L[k]处取得
7.	i = 1
8.	j = k
9.	do
10.		T[i] = S[j] , i = i + 1 , j = P[j]
11.	until j = 0
12.	for i = L[k] down to 1
13.		print T[i]

```

![2](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/2.png)


对于最长单调递减子序列，处理方法同最长单调递增子序列。只需要更改一下对应的循环条件。因此，这里不再赘述，仅仅给出伪代码。

```
输入：序列S[1]S[2]S[3]...S[n]
输出：输入序列的最长单调递减子序列的长度len
1. for i=n downto 1 do
2.		R[i] = 1
3.		for j=i to n do
4.			if S[j] < S[i] and R[j] >= R[i] then
5.				R[i] = R[j] + 1
6.	len = max{R[1],R[2],...,R[n]}
```

# 三、最大子段和问题

> ***问题描述***：给定n个整数（可能为负整数）组成的序列 a_1 , a_2 , ... , a_n , 求该序列的形如 a_i + a_{i+1} + ... + a_j 的和中的最大非负值。如果该序列中所有字段和均为负整数的时候，定义其最大的字段和为0。

​​&nbsp;&nbsp;	我们来分析一下这个问题，如果我们用蛮力法，就是在长度为n的序列中找到所有的可能连续子段，大约有 n^2/2 个不同的子段和。我们只需要计算每一个值即可，然后找最大值。因此，此时时间复杂度是O(n^2)的，那么我们能否用少于该时间复杂度的算法实现呢？答案是可以的。

​&nbsp;&nbsp;​	下面我们来介绍一下 Kadane 算法。

$$
令C[j]表示必须以元素a_j结尾(因此长度至少为一)的最大字段和(允许为负值)，即\quad C[j] = max \{\sum_{\quad k=1}^{j}a_k \}其中 1 \le i \le j\\
因此我们的目标就是计算max\{ 0 , max\{ C[j](其中1 \le j \le n) \} \}
$$

​&nbsp;&nbsp;​	因此，现在我们的问题转化为求每一个 C[j] 。我们来看一下 C[j] 的可能取值。

> 在该情况下，就只有两种情况。
>
> （1）长度为一，即仅仅包含 a_j
>
> （2）长度大于一

​&nbsp;&nbsp;​	那我们分析一下，我们是如何计算以 a_j 结尾的最大字段和的。假设现在以 a_j 结尾的最大字段和是从 a_i + a_{i+1} + ... + a_{j-1} + a_j 。那么我们为什么是要加上 a_i + a_{i+1} + ... + a_{j-1}呢，是因为 a_i + a_{i+1} + ... + a_{j-1} 恰好是 C[j-1] ，也就是以 a_{j-1} 结尾的大字段和，如果   C[j-1]>0 , 那么以 a_j 结尾的最大字段和一定是 C[j] + a_j ，因为一个数加上一个正数不可能会变小（虽然加完之后的值可能不一定为正数）。那么如果 C[j-1] < 0 ，那么以 a_j 结尾的最长字段和不可能是 C[j-1] + a_j 。因为一个数加上一个负数不可能变大。于是，我们就得到了一个如下的递推关系。

$$
C[j] = 
\begin {cases}
a_j + C[j-1] && if \quad C[j-1] > 0\\
a_j && else
\end {cases}
$$

  ![3](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/3.png)

于是，伪代码如下：

```
Algorithm MaxSum(A,n)
输入：数组/序列A，长度n
输出：最大字段和sum
1.	C[0] = 0
2.	for j = 1 to n do
3.		C[j] = a_i
4.		if C[j-1] > 0 then
5.			c[j] = c[j-1] + a_j
6.	sum = max{C[j]} for all j
```

​&nbsp;&nbsp;​	那么如果我们不仅要找到最长字段和，还要找到取得最长字段和的具体字段，那么我们就需要一个标记函数。
​​&nbsp;&nbsp;	我们使用一个二元组 （s(i) , f(j)）来记录取得 C[j] 时的具体时段，即（start，end）。因此，对于 C[j] 的两种可能情况，如果是第一种，也就是说 C[j] = a_j ，那么（s(i) , f(j)） = （ j , j )

​&nbsp;&nbsp;​	如果是第二种，那么 C[j] = C[j-1] + a_j ，也就是说结束位置不变，但是开始位置要前移。因此，此时（s(j) , f(j)） = （ s(j-1) , f(j) ）。因此对于上面的伪代码，我们只需要记录一下即可。

 ```
Algorithm MaxSum(A,n)
输入：数组/序列A，长度n
输出：最大字段和sum
1.	C[0] = 0 , s[0] = 0 , f[0] = 0
2.	for j = 1 to n do
3.		C[j] = a_i , s[j] = j , f[j] = j
4.		if C[j-1] > 0 then
5.			c[j] = c[j-1] + a_j , s[j] = s[j-1]
6.	sum = max{C[j]} for all j
 ```

# 0-1 背包问题

> ***问题描述*** ：背包问题是一个经典的组合优化问题。假设共有 n 种物品，其中第 i 种物品的价值为 v_i , 重量为 w_i , 假定 v_i 和 w_i 都是整数，确定要从这 n 种物品中选择那些种，每种选择多少，将其装入背包，使得这些物品的总重量不超过给定的限制W并且总价值尽可能大。

​&nbsp;&nbsp;​	我们在贪婪算法的时候曾经用贪婪策略求解过0-1背包问题，当时我们发现，贪婪解无法保证获得最优解，甚至对于0-1背包问题的效果可能非常差。因此，这里我们换一种方式来思考0-1背包问题，采用动态规划的方式来获得最优解。

​&nbsp;&nbsp;​	考虑下述子问题 F(k,y) —— 使用前 k 种物品，且背包容量为 y 时的最优解总价值。所以原问题的目标即求解 F(n,W)。 

​&nbsp;&nbsp;​	那么我们来看，对于第 k 个物品，无外乎只有两种可能情况，**拿** or **不拿** 。因此，我们至于要分别计算出这两种情况下能够在不超过背包总容量的情况下获得的最大价值，取大者即可。那么，下面的问题就是如何确定这两种情况下的最大价值是多少。现在考虑前 k 种物品，背包限重为 y ，如果 ***拿了第k个物品*** ，那么此时能获得的最大价值为 ***F( k - 1 , y - w_k) + v_k*** 也就是在考虑前  i-1 个物品，且背包总重量不超过 y - w_k 的情况下的最大价值。如果 ***不拿第k个物品*** ,那么此时能够获得的最大总价值为 ***F( k - 1 , y - w_k) + v_k*** ，也就是在考虑前 i-1 个物品，且背包总重量不超过y的情况下的最大价值。那么我们看，计算 F( k , y ) 的时候需要用到 F( k-1 , y) 以及 F( k-1 , y-1)。也就是说，我们计算 F( k , y ) 的时候， F( k-1 , y) 以及 F( k-1 , y-1)必须已经计算过。那么观察一下这两个值在二维表中的具体位置，可知是在 *** F( k , y )的上方以及左上方*** ，因此，这也就确定了我们的填表顺序，***从左上依次填表到右下，按行从左到右填表*** 。

​&nbsp;&nbsp;​	上面我们简要分析了一下 F( k , y ) 的求解，那么我们来考虑递推式以及初值。

> （1） 如果此时没有物品可供选择，那么背包容量无论多少，能够获得的最大价值只能为0，因为无东西可拿。
>
> （2）如果此时背包容量为0，那么无论物品的价值是多少，都无法获得价值，因为无法装入到背包中去。
>
> （3）如果不选择物品k，那么就是 F( k-1 , y)
>
> （4）如果选择物品k
>
> > 1 .如果第k个物品的重量超过了此时背包的重量限制 y ，那么无论该物品价值是多少，都无法装入背包。
> >
> > 2.如果第k个物品重量没超过背包重量限制y，那么就要考虑 F( k - 1 , y - w_k) + v_k 与
> >
> >  F( k - 1 , y - w_k) + v_k 中的最大值。

​&nbsp;&nbsp;于是，我们可以得到如下递推式。

$$
F(k,y) = 
\begin {cases}
0 && if \quad k=0 \quad or \quad y=0 \\
F(k-1,y) && if \quad w_k > y \\
max\{F(k-1,y) ,F(k-1,y-w_k)+v_k\} && else
\end {cases}
$$

因此，伪代码如下：

```
1.	for y = 0 to W
2.		F(0,y) = 0
3.	for k = 1 to n
4.		F(k,0) = 0
5.	for k = 1 to n
6.		for y = 1 to W
7.			if(w_k > y) do
8.				F(k,y) = F(k-1,y)
9.			else
10.				F(k,y) = max{F(k-1,y),F(k-1,y-w_k)+v_k}
11.	return F(n,W)
```

![4](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/4.png)

​&nbsp;&nbsp;那么我们如何回溯找到最优解是拿了那些物品而得到的呢？这个时候我们就需要一个标记函数来辅助回溯。我们仍然定义辅助函数为 P(k,y)。他表示在考虑前k个物品，背包总重量为y的情况下，加入的物品的重量。

​&nbsp;&nbsp;以上述例子为例，P(5,11) = 0 ,因此下一个找P(4,11),而 P(4,11) = 6 ,于是第四个物品拿了，下一个找P(3,5)。以此类推，可以得到拿了物品3和物品4。

![5](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/5.png)

# 五、投资问题

> 问题抽象：
> 
> $$
> 有m元钱，n项可能的投资项目。f_i(x)表示将x元投入第i个项目能获得的收益。这里假设f_i(x)非负且是x的不减函数
> $$
>
> $$
> 目标是将投资的收益最大化，即\max\{f_1(x_1) + f_2(x_2)+...+f_n(x_n)\}.这里我们假设所有钱都投进去，即\sum_i x_i = m
> $$

​	这个问题和背包问题很像，都是在受限条件下求解最大收益问题。因此，我们用类似于背包问题的求解思路来思考该问题。

$$
设F_k(x)表示对前k个项目进行共计x元的投资所能取得的最大收益。x_k表示在F_k(x)中投资给项目k的钱数。
$$

$$
给前k个项目投资x元，那么如果第k个项目投资x_k元，前k-1个项目就只能投资x-x_k元。因此我们可以写出递推式。
$$

$$
F_k(x) = \max_{0<=x_k<=x}\{f_k(x_k)+ f_{k-1}(x - x_k) \} \quad 0\le x \le m , 2\le k\le n。
$$

$$
F_1(x) = f_1(x) \quad 0\le x \le m \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad
$$

举个栗子，以第最后一个项目为例。可以给第四个项目投资0元，那么前三个项目投资5元。以此类推，给第四个项目投资1元，前三个项目投资4元...第四个项目投资5元，前三个项目投资0元。我们依次计算能够获得的收益，然后取最大值。

![image-20240621163607239](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/11.png)

因此，伪代码如下：

```
1.	for y = 1 to m
2.		F_1(y) = f_1(y)
3.	for k = 2 to n
4.		for y = 1 to m
5.			F_k(y) = max_{0 <= x_k <= y} {f_k(x_k) + F_{k-1}(y-x_k)}
6.	return F_n(m)
```

# 六、最长公共子序列（LCS）

> 问题描述：在两个序列之间找到一个具有最大长度的公共子序列。**最长公共子序列不唯一，但长度一定是惟一的**

给出求解思路

令len ( i , j ) 表示 X[1...i] 和 Y[1...j]的LCS长度，0<=i<=m, 0<=j<=n。给出递推式

$$
len(i,j) = \begin{cases}
len(i-1,j-1) + 1 && X[i]=Y[j]\\
max(len(i-1,j),len(i,j-1)) && else
\end{cases}
$$

给出伪代码

```
1.	for i = 1 to m
2.		len(i,0) = 0
3.	for j = 1 to n
4.		len(0,j) = 0
5.	for i = 1 to m
6.		for j = 1 to n
7.			if X[i]=Y[j] then
8.				len(i,j) = len(i-1,j-1) + 1
9.			else if len(i-1,j) >= len(i,j-1) then
10.				len(i,j) = len(i-1,j)
11.			else len(i,j) = len(i,j-1)
12.	return len(m,n)
```

![image-20240621165315445](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/12.png)

下面介绍如何回溯找到最长子序列的组成元素。定义b（i,j)=1,2,3分别代表len(i,j)是由左上角、上方、左侧的元素组成的。因此，我们构造一个标记函数矩阵。按照箭头的方向反序输出，即可得到最长公共子序列。下面给一个示例：

![image-20240621165617764](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/13.png)

伪代码为:

```
1.	for i = 1 to m
2.		len(i,0) = 0
3.	for j = 1 to n
4.		len(0,j) = 0
5.	for i = 1 to m
6.		for j = 1 to n
7.			if X[i]=Y[j] then
8.				len(i,j) = len(i-1,j-1) + 1 , b(i,j) = 1
9.			else if len(i-1,j) >= len(i,j-1) then
10.				len(i,j) = len(i-1,j), b(i,j) = 2
11.			else len(i,j) = len(i,j-1), b(i,j) = 3
12.	return len(m,n)
```

# 七、最短公共超序列（SCS）

> 定义：设X和Y是两个序列，如果X和Y都是Z的子序列，那么乘序列Z是X和Y的**公共超序列。**
>
> 其中，X和Y的一个最短长度的公共超序列叫做X和Y的最短公共超序列。

​	这里我们还是按照类似最长公共子序列的方式来进行求解。首先考虑最有一个元素。如果相等，那么最长公共超序列的长度就是len(i-1,j-1)+1。如果不相等，那么我们考虑前len(i-1,j)和len(i,j-1)。这里与LCS不同之处就在于，如果最后一项不相同，那么我们就要找前i-1和j-1项的最短公共超序列的长度，然后在加上某一个序列的最后一个字符，即构成了最短公共超序列。

$$
len[i,j] = \begin{cases}
j && i = 0\\
i && j = 0 \\
len[i-1,j-1] + 1 &&if x_i = y_j\\
\min\{len[i,j-1],len[i,j-1] \}+1 && else
\end{cases}
$$

![image-20240621171420659](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/14.png)

因此，伪代码为：

```
1.	for i = 0 to n do
2.		len[i,0] = i
3.	for j = 0 to m do
4.		len[0,j] = j
5.	for i = 1 to n do
6.		for j = 1 to m do
7.			if X[i] = Y[j] then
8.				len[i,j]= len[i-1,j-1] +1
9.			else 
10.				len[i,j] = min{len[i,j-1],len[i-1,j]}+1
11. return len[n,m]
```

​	下面介绍如何用回溯的方式找到最短公共超序列。仍然采用上述标记方法，不过在最长公共子序列中只有斜着走的时候，我们取了该元素。在最短公共超序列这里，我们要取路径上的所有元素。如下图所示。

![image-20240621171957339](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/15.png)

伪代码如下：

```
1.	for i = 0 to n do
2.		len[i,0] = i
3.	for j = 0 to m do
4.		len[0,j] = j
5.	for i = 1 to n do
6.		for j = 1 to m do
7.			if X[i] = Y[j] then
8.				len[i,j]= len[i-1,j-1] +1
9.			else if len[i-1,j] >= len[i,j-1] then
10.				len[i,j] = len[i,j-1] + 1 , b[i,j] = 3
11.			else len[i,j] = len[i-1,j] +1, b[i,j] = 2
12. return len[n,m]
```

这里介绍一个LSC和SCS相互转化的公式：

> 假设|X| = m ，|Y| = n，|LCS| = L，|SCS| = K，那么则有
>
> L + K = m +n

举个栗子：

![image-20240621173239517](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/16.png)

也就是说，如果只会求最长公共子序列，那么完全就可以完全求解最短公共超序列。

# 八、矩阵链乘积

> 问题描述：
> $$
> 假定给定了矩阵的序列A_1,A_2,A_3,...,A_n,其中A_i为P_{i-1}*P_i阶矩阵，目的是计算他们的链乘积。\\
> 由于矩阵乘法满足交换律，因此无论计算过程是什么样的，他们最终的结果都是一致的，但是效率不一样。\\
> 试确定矩阵相乘的次序，使得矩阵元素相乘的总次数最少。\qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad
> $$

​	为了解决这个问题，我们首先还是给出几个贪婪解题思路：

> 1.【最多元素乘法次数优先】:每次优先选择使用元素乘法次数最多的两个矩阵相乘
>
> 2.【最少元素乘法次数优先】：每次优先使用最少元素乘法次数的两个矩阵相乘。

然而不幸的是，我们发现，上述两种思路均存在反例，也就是说，并不是有效方案。

反例1：

![image-20240621193638695](C:\Users\MHB\AppData\Roaming\Typora\typora-user-images\image-20240621193638695.png)

反例2：![image-20240621193718598](C:\Users\MHB\AppData\Roaming\Typora\typora-user-images\image-20240621193718598.png)

因此，我们采用动态规划的方式来进行思考。通过以上案例的分析，我们仍然首先考虑最后一次乘法。举个栗子：现在有四个矩阵A_1,A_2,A_3,A_4相乘，那么最后一次乘法可以是

> A_1 | A_2 A_3 A_4
>
> A_1 A_2 | A_3 A_4
>
> A_1 A_2 A_3 | A_4

那么我们就得到了解的所有组成方式。也就是说，该四个矩阵相乘的乘法总次数最小值就在这三个解中产生。因此，我们便得到了动态规划递推式的思路。因为此时已经满足我们知道解的所有情况，但不知道是那种情况而来的最优解。

$$
将A_i*A_{i+1}*...*A_j的乘积记作A_{ij}(j\ge i)。令m(i,j)表示计算A_{ij}的最优方式所需的乘法总次数。定义i=j时，m(i,j)=0
$$

$$
假设计算A_{ij}的最后一次矩阵乘法是A_{ij}=A_{ik}*A_{kj},其中i \le k < j.A_{ik}的阶数为P_{i-1}*P{k},A_{kj}的阶数为P_{k-1}*P_j。\quad \quad \quad 
$$

$$
因此这次乘法次数为P_{i-1}*P_k*P_j.而计算A_{ik}的乘法次数是m(i,k),计算A_{kj}的乘法次数是m(k+1,j)。于是，当前总开销为
$$

$$
m(i,k)+m(k+1,j)+P_{i-1}*P_{k}*P_{j}。因此，此时的关键就是k在哪里取值。我们知道，最后一次乘法一定会发生的，无论在哪
$$

$$
于是不妨我们都试一试，让k在i，i+1,...,j-1后面都试一试，然后选择其中总开销最小的一个。
$$

因此，我们就得到了如下递推式
$$
m(i,j) = \begin{cases}
0 && i=j \\
\min_{i\le k \le j}\{m(i,k)+m(k+1,j)+P_{i-1}*P_k*Pj \} && i < j
\end{cases}
$$

 由上述递推式可知，我们在填表的时候不能按照以往的方式，从左上到右下一行一行的填表。因为我们在填表m(i,j)的时候，要求我们知道i所在行，j所在列的已经填完表的值。于是，由递推式可知，我们要按照对角线的方向，从中间向右上角填表。

![image-20240621195122222](C:\Users\MHB\AppData\Roaming\Typora\typora-user-images\image-20240621195122222.png)

​	于是我们设 L为矩阵链乘积的长度，首先计算L=1的最优开销，然后依次计算L=2，3,...n的最优开销。因此，我们需要填两个表，最优开销表m和划分表s。

​	下面给出伪代码实现：

```
MATRIX-CHAIN-ORDER
输入：序列P_0,P_1,P_2,...,P_n
输出：最优开销表m和划分表s
1.	for i = 1 to n
2. 		m(i,i) = 0 , s(i,i) = 0
3.	for l = 2 to n
4.		for i = 1 to n-l+1
5.			j = i + l - 1
6.			m(i,j) = ∞
7.			for k = i to j - 1
8.				q = m(i,k) + m(k+1,j)+P(i-1)P(k)P(j)
9.				if q < m(i,j) then
10.				m(i,j) = q, s(i,j) = k
11.	return m,s
```

下面举个栗子：

| 矩阵 | 阶数  |
| :--: | :---: |
|  A1  | 30*35 |
|  A2  | 35*15 |
|  A3  | 15*5  |
|  A4  | 5*10  |
|  A5  | 10*20 |
|  A6  | 20*25 |

| i/j  |  1   |   2   |  3   |  4   |   5   |   6   |
| :--: | :--: | :---: | :--: | :--: | :---: | :---: |
|  1   |  0   | 15750 | 7875 | 9375 | 11875 | 15125 |
|  2   |  -   |   0   | 2625 | 4375 | 7125  | 10500 |
|  3   |  -   |   -   |  0   | 750  | 3500  | 5375  |
|  4   |  -   |   -   |  -   |  0   | 1000  | 3500  |
|  5   |  -   |   -   |  -   |  -   |   0   | 5000  |
|  6   |  -   |   -   |  -   |  -   |   -   |   0   |

| i/j  |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  0   |  1   |  1   |  3   |  3   |  3   |
|  2   |  -   |  0   |  2   |  3   |  3   |  3   |
|  3   |  -   |  -   |  0   |  3   |  3   |  3   |
|  4   |  -   |  -   |  -   |  0   |  4   |  5   |
|  5   |  -   |  -   |  -   |  -   |  0   |  5   |
|  6   |  -   |  -   |  -   |  -   |  -   |  0   |

第一步，对角线置为0，下三角区域为-。

第二步，计算L=2时的矩阵乘法次数。即m（1,2），m(2,3)，m(3,4)，m(4,5)，m(5,6)

第三步，计算L=3时的矩阵乘法次数。即m(1,3)，m(2,4)，m(3,5)，m(4,6)

以m(1,3)为例，m(1,3)=min{ m(1,1)+m(2,3)+30\*35\*5 , m(1,2)+m(3,3)+30\*15\*5}

​				     = min{ 0+2625+5250 , 15750 + 0 + 2250}

​				     = 7875

也就是说，此时是计算最后括号加在了A1后。即 A1\*（A2\*A3）所以s(1,3) = 1

第四步，计算L=4时的矩阵乘法次数，即m(1,4)，m(2,5)，m(3,6)

以m(1,4)为例，

m(1,4)=min{ m(1,1)+m(2,4)+30\*35\*10 , m(1,2)+m(3,4)+30\*15\*10 ,m(1,3)+m(4,4)+30\*5*10}

​	  = min{0 + 4375 +10500, 15750+750+4500 , 7875 + 0 + 1500}

​	 =9375

也就是说，此时最后一次括号加在了A3后。即(A1\*A2\*A3)*A4，所以S(1,4)=3

第五步，计算L=5时的矩阵乘法次数，即m(1,5)，m(2,6)

第六步，计算L=6时的矩阵乘法次数，即m(1,6)

---

下面演示一下如何从标记表s找到括号加的位置。

首先看右上角元素为3，也就是说，最后一个括号加在了A3的后面，因此为

（A1A2A3）*（A4A5A6）

于是分别左右画一道线。【这里画线的原则是，A1-A3的顺序还没确定，因此第一道线看画完之后的左侧，A4-A6的顺序还没确定，因此第二道线画完之后看他的右侧】

![image-20240621201543743](C:\Users\MHB\AppData\Roaming\Typora\typora-user-images\image-20240621201543743.png)

我们看到，左侧的最右上角元素为1，右侧最右上角元素为5，也就是说，A1A2A3的括号加在了A1后面，A4A5A6的括号加在了A5后面。于是(A1（A2\*A3） )*((A4\*A5)\*A6)

![image-20240621201801513](C:\Users\MHB\AppData\Roaming\Typora\typora-user-images\image-20240621201801513.png)继续画两道线，可知括号分别加在了A2和A4之后。因此，矩阵乘法次序已然确定。即

（A1\*(A2\*(A3)）*（(A4\*(A5)\*A6）

# 九、最优二叉查找树

> 问题描述：给定n个不同的键值k1，k2，... , kn，每个键值ki被访问的概率为pi。假设k1<k2<...<kn，p1+p2+...+pn = 1。应该如何构建二叉查找树以最小化其查找的期望开销。

举个栗子：

![image-20240621202821203](C:\Users\MHB\AppData\Roaming\Typora\typora-user-images\image-20240621202821203.png)

​	然而，如果概率p发生变化，上述5颗树每一颗都有可能是最优的。因此，我们不是要试图构建一颗AVL树，而是要优化道路的加权平均长度。

​	并且，内部节点也包含键值，并且因查找而固定了树中节点的中序次序，因此和Huffman编码的问题背景、适用条件不同。但是基本原则类似：**具有更大访问概率的键值的顶点应更接近于根**。

![image-20240621203808846](C:\Users\MHB\AppData\Roaming\Typora\typora-user-images\image-20240621203808846.png)

​	设 T（i,j)表示对应于键值k_i,....,k_j的最优二叉查找树。并令C(i,j)表示此时成功查找的期望开销。当 i > j 时，T(i,j)为空树，C（i,j) = 0。考虑T（i,j)的根，如果根的键值为k_s。那么左子树的键值为k_1 ~ k_s , 右子树的键值为 k_s+1 ~ k_j。此时 C（i,j) = p_s*1 + cost_left + (p_i +....+p_{s-1}) * 1 + cost_right + (p_{s+1},...,p_j)*1 = C(i,s-1) + C(s+1,j) + (p_i + ....+ p_j)。

​	C(i,j) = min{ C(i,s-1) + C(s+1,j) + (p_i + ....+ p_j)  }

​	此时转化为类似于矩阵连乘积的求解。

# 十、跳棋棋盘问题

> 问题描述：考虑一个n*n的方格棋盘，第i行和第j列的开销为c（i,j）。假设有一个棋盘和一枚棋子，从最下面一行的方格（1，3）开始，棋子每步只能沿对角线左前方、正前方或者右前方跳一格。希望棋子跳到最上面一行，并且途径的方格总开销达到最小。

![image-20240621204114613](C:\Users\MHB\AppData\Roaming\Typora\typora-user-images\image-20240621204114613.png)

于是定义函数q(i,j)为到达方格（i,j）的最小总开销。目标就是计算min{ q(n,j) }。

该题的递推式很容易得到，**q(i,j) = min{q(i-1,j),q(i-1,j-1),q(i-1,j+1)} + c(i,j)**。但是如果直接采用原棋盘，我们会发现。最左侧一列和最右侧一列，无法使用该递推式。虽然可以用if限定条件来进行判断，但是为了更加普遍的使用该递推式，于是我们在最左侧和最右侧分别加了一列元素。以便于在每一个位置都能使用该递推式。

![image-20240621204447524](C:\Users\MHB\AppData\Roaming\Typora\typora-user-images\image-20240621204447524.png)

于是给出伪代码：

```
1.	for x = 1 to n
2.		q(1,x) = ∞
3.	q(1,(n+1)/2) = c(1,x)
4.	for y = 1 to n
5.		q(y,0) = ∞
6.		q(y,n+1) = ∞
7.	for y = 2 to n
8.		for x = 1 to n
9.			m = min{ q(y-1,x-1),q(y-1,x),q(y-1,x+1) }
10.			q(y,x) = m + c(y,x)
11.			if m = q(y-1,x-1) then
12.				p(y,x) = -1
13.			else if m = q(y-1,x) then
14.				p(y,x) = 0
15.			else p(y,x) = 1
```



