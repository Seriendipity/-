$$
\color{red}说明：下述题目分析中用到的题目和图片均来自刘铎老师的PPT，仅供个人学习使用
$$


# 动态规划

​  &nbsp;&nbsp;在介绍动态规划之前，我们首先要说明一个问题。 ***递归和迭代的优缺点***  来为了下面使用动态规划算法做铺垫。

> 递归

​&nbsp;&nbsp;	首先，我们在分治的时候已经接触过递归算法了。在程序设计中， ***若一个函数在其函数体内又直接调用了自身，则称之为递归函数。*** 递归函数的特性就是：问题和子问题具有相同的结构、子问题的规模逐渐递减、有终止条件作为出口。这是一种 **自上而下** 的计算方式。

> 迭代

​&nbsp;&nbsp;	迭代法是一种不断用已经计算过的值来计算新的值的过程，它是一种 **自下而上** 的计算方式。

---

​	&nbsp;&nbsp;我们来看一个例子，斐波那契数列。它具有以下递推关系：

$$
F(n) = F(n-1) + F(n-2)
$$

​&nbsp;&nbsp;	其中F(1) = 1 , F(2) = 1 , 定义了如下序列 1,1,2,3,5,8...，因此我们可以得到如下两种算法

***递归算法*** 

```
Algorithm F(n)
if(n <= 2) then
	return 1
else
	return F(n-1) + F(n-2)
```

***迭代算法***

```
Algorithm F(n)
F[1] = 1 , F[2] = 1
for i = 3 to n
	F[i] = F[i-1] + F[i-2]
return F[n]
```

​&nbsp;&nbsp;	于是，我们可以看到，在递归算法，一旦n非常大，那么会有非常多的（***往往是指数阶***）的重复运算，比如我要算F(100)我要计算F(99)+F(98),然后再递归调用F(99)，那么就要计算F(98)+F(97)...，每次都含有大量的重复计算，因此会非常耗时间***（往往是我们无法接受的）***，这也是自上而下计算的缺点所在。

​&nbsp;&nbsp;	而迭代算法，是一种自下而上的运算方式。他从下开始往上填表，在填写新的值的时候可以直接用已经填好的数字进行计算，而不是再重复计算一次。比如同样计算F(100),在我计算F（100）的时候，其中前99项已经计算完成了，我只需要将两个数加起来（O(1)时间）就完成，因此时间是非常短的。

---

​	&nbsp;&nbsp;那么有小伙伴可能会有疑问了？为什么分治算法的时候，我们都是使用递归算法，但是不会产生这种时间爆炸的现象呢？

​&nbsp;&nbsp;	这是因为，我们分治算法的核心策略是将问题转化为具有相同问题模式的规模减小的子问题，其中每次都会舍弃一部分数据，不会有重复计算的过程。比如二分查找，每次舍弃一半数据，在剩下的数据中进行查找，不会再访问前半部分；比如归并排序，每次分成两半，在对应的一半再进行递归调用，不会重复计算。……

​&nbsp;&nbsp;	因此，***在分治算法中，我们多采用递归方式；而在接下来介绍的动态规划中，我们多采用迭代的方式。***

​	

# 一、找零问题

> 问题描述：给定数值 n 和 m 种硬币的面值 d_1 , d_2 , ... , d_m ，设计一种方法，能够用最少数量硬币凑出总和 n 。

&nbsp;&nbsp;​	在解决这个问题之前，我们先举一个简单的例子，在之前贪婪策略的时候，我们曾经举过这样一个例子，我们这里沿用该例子。给定数值 19 和 4 种面值为1元、5元、7元、10元的硬币，如何用最少的硬币数量向顾客支付19元。

&nbsp;&nbsp;​	我们知道，此时贪婪算法失效。那么我们换一种策略来思考问题。不论我们找给顾客哪一枚硬币，我们总要给顾客一枚的，那么我们可以分成以下几种情况。

> 给顾客一枚1元硬币，之后按最优方式找给顾客18元
>
> 给顾客一枚5元硬币，之后按最优方式找给顾客14元
>
> 给顾客一枚7元硬币，之后按最优方式找给顾客12元
>
> 给顾客一枚10元硬币，之后按最优方式找给顾客9元

​&nbsp;&nbsp;	我们发现，无外乎就这四种情况，我们能够知道每一个求解方式的 “由来” ，但是不知道是由哪个解构成的最优解。那么我们完全可以分别计算这四个值，哪个值最小，我们取哪个值。
&nbsp;&nbsp;​	于是，我们就成功的应用了动态规划的思想。在该问题中，每一个n值都可能有多个解，我们希望找到一个最优解，我们知道解的构成，但是不知道哪个解是最优解，于是利用 ***状态转移方程*** 来不断计算最优解，以达到我们的目的。

​&nbsp;&nbsp;	于是，对于该问题，我们得到一个递推式：

$$
令d(i)表示凑出i元所需的最少硬币数量。初始值d(0)=0,d(i)= \infty \quad (i \neq 0)
$$

$$
于是d(i) = min\{ d(i-d_k)\}+1 \quad 其中(k=1,2,...,m \quad i \ge d_k)
$$

​&nbsp;&nbsp;	也就是说，对于d(12)来说，d(12) = min { d(2) , d(5) , d(7) , d(11) } + 1。我们在计算的时候，把每个解都填在表中，在后续填表的时候只需要到表的对应位置去取值就可以。这也就是动态规划又叫  ***填表法***  的由来。

​&nbsp;&nbsp;	***我们一定要保证填在表中的每一个值都是最优解的值，并且初值很重要*** ， 一旦初值错误，那么后续所有的填表可能都是错的。

![1](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/1.png)

​	&nbsp;&nbsp;于是，对于面值为1、5、7、10的伪代码如下：

```
Find(n)
1.	find[0] = 0
2.	if i < 0 then find[i] = ∞
3.	for i = 1 to n
4.		find[i] = min {find[i-1] , find[i-5] , find[i-7] , find[i-10]} + 1
5.	return find[n]
```

​&nbsp;&nbsp;	对于其他面值的硬币，只需要将第4行伪代码中的 find[ i - d_k ] 进行变化即可。
