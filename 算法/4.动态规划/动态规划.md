$$
\color{red}说明：下述题目分析中用到的题目和图片均来自刘铎老师的PPT，仅供个人学习使用
$$


# 动态规划

​  &nbsp;&nbsp;在介绍动态规划之前，我们首先要说明一个问题。 ***递归和迭代的优缺点***  来为了下面使用动态规划算法做铺垫。

> 递归

​&nbsp;&nbsp;	首先，我们在分治的时候已经接触过递归算法了。在程序设计中， ***若一个函数在其函数体内又直接调用了自身，则称之为递归函数。*** 递归函数的特性就是：问题和子问题具有相同的结构、子问题的规模逐渐递减、有终止条件作为出口。这是一种 **自上而下** 的计算方式。

> 迭代

​&nbsp;&nbsp;	迭代法是一种不断用已经计算过的值来计算新的值的过程，它是一种 **自下而上** 的计算方式。

---

​	&nbsp;&nbsp;我们来看一个例子，斐波那契数列。它具有以下递推关系：

$$
F(n) = F(n-1) + F(n-2)
$$

​&nbsp;&nbsp;	其中F(1) = 1 , F(2) = 1 , 定义了如下序列 1,1,2,3,5,8...，因此我们可以得到如下两种算法

***递归算法*** 

```
Algorithm F(n)
if(n <= 2) then
	return 1
else
	return F(n-1) + F(n-2)
```

***迭代算法***

```
Algorithm F(n)
F[1] = 1 , F[2] = 1
for i = 3 to n
	F[i] = F[i-1] + F[i-2]
return F[n]
```

​&nbsp;&nbsp;	于是，我们可以看到，在递归算法，一旦n非常大，那么会有非常多的（***往往是指数阶***）的重复运算，比如我要算F(100)我要计算F(99)+F(98),然后再递归调用F(99)，那么就要计算F(98)+F(97)...，每次都含有大量的重复计算，因此会非常耗时间***（往往是我们无法接受的）***，这也是自上而下计算的缺点所在。

​&nbsp;&nbsp;	而迭代算法，是一种自下而上的运算方式。他从下开始往上填表，在填写新的值的时候可以直接用已经填好的数字进行计算，而不是再重复计算一次。比如同样计算F(100),在我计算F（100）的时候，其中前99项已经计算完成了，我只需要将两个数加起来（O(1)时间）就完成，因此时间是非常短的。

---

​	&nbsp;&nbsp;那么有小伙伴可能会有疑问了？为什么分治算法的时候，我们都是使用递归算法，但是不会产生这种时间爆炸的现象呢？

​&nbsp;&nbsp;	这是因为，我们分治算法的核心策略是将问题转化为具有相同问题模式的规模减小的子问题，其中每次都会舍弃一部分数据，不会有重复计算的过程。比如二分查找，每次舍弃一半数据，在剩下的数据中进行查找，不会再访问前半部分；比如归并排序，每次分成两半，在对应的一半再进行递归调用，不会重复计算。……

​&nbsp;&nbsp;	因此，***在分治算法中，我们多采用递归方式；而在接下来介绍的动态规划中，我们多采用迭代的方式。***

​	

# 一、找零问题

> 问题描述：给定数值 n 和 m 种硬币的面值 d_1 , d_2 , ... , d_m ，设计一种方法，能够用最少数量硬币凑出总和 n 。

&nbsp;&nbsp;​	在解决这个问题之前，我们先举一个简单的例子，在之前贪婪策略的时候，我们曾经举过这样一个例子，我们这里沿用该例子。给定数值 19 和 4 种面值为1元、5元、7元、10元的硬币，如何用最少的硬币数量向顾客支付19元。

&nbsp;&nbsp;​	我们知道，此时贪婪算法失效。那么我们换一种策略来思考问题。不论我们找给顾客哪一枚硬币，我们总要给顾客一枚的，那么我们可以分成以下几种情况。

> 给顾客一枚1元硬币，之后按最优方式找给顾客18元
>
> 给顾客一枚5元硬币，之后按最优方式找给顾客14元
>
> 给顾客一枚7元硬币，之后按最优方式找给顾客12元
>
> 给顾客一枚10元硬币，之后按最优方式找给顾客9元

​&nbsp;&nbsp;	我们发现，无外乎就这四种情况，我们能够知道每一个求解方式的 “由来” ，但是不知道是由哪个解构成的最优解。那么我们完全可以分别计算这四个值，哪个值最小，我们取哪个值。
&nbsp;&nbsp;​	于是，我们就成功的应用了动态规划的思想。在该问题中，每一个n值都可能有多个解，我们希望找到一个最优解，我们知道解的构成，但是不知道哪个解是最优解，于是利用 ***状态转移方程*** 来不断计算最优解，以达到我们的目的。

​&nbsp;&nbsp;	于是，对于该问题，我们得到一个递推式：

$$
令d(i)表示凑出i元所需的最少硬币数量。初始值d(0)=0,d(i)= \infty \quad (i \neq 0)
$$

$$
于是d(i) = min\{ d(i-d_k)\}+1 \quad 其中(k=1,2,...,m \quad i \ge d_k)
$$

​&nbsp;&nbsp;	也就是说，对于d(12)来说，d(12) = min { d(2) , d(5) , d(7) , d(11) } + 1。我们在计算的时候，把每个解都填在表中，在后续填表的时候只需要到表的对应位置去取值就可以。这也就是动态规划又叫  ***填表法***  的由来。

​&nbsp;&nbsp;	***我们一定要保证填在表中的每一个值都是最优解的值，并且初值很重要*** ， 一旦初值错误，那么后续所有的填表可能都是错的。

![1](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/1.png)

​	&nbsp;&nbsp;于是，对于面值为1、5、7、10的伪代码如下：

```
Find(n)
1.	find[0] = 0
2.	if i < 0 then find[i] = ∞
3.	for i = 1 to n
4.		find[i] = min {find[i-1] , find[i-5] , find[i-7] , find[i-10]} + 1
5.	return find[n]
```

​&nbsp;&nbsp;	对于其他面值的硬币，只需要将第4行伪代码中的 find[ i - d_k ] 进行变化即可。

# 二、最长单调递增子序列

​&nbsp;&nbsp;​	***子序列定义***：序列S的子序列是从S中删除零项或者多项并保持其余项的原有次序得到的。

> 例如：pred，sdn，predent都是 “president”的子序列
>
> > 子序列不同于子串，子串是连续的。比如pre，sident为子串。

$$
\color{red}{单调定义}\color{black}:给定数值x_1,x_2,...,x_n构成的序列S，若其子序x_{i_1},x_{i_2},...,x_{i_k}(i_{j+1} > i_{j})对所有的j都满足x_{i_{j+1}}>x_{i_j},称该子序列单调 \qquad \qquad \qquad \qquad \qquad 
$$

> 问题描述：希望找到S的一个最长单调子序列（LCS），可能不唯一。但是LCS的长度是惟一的。

​&nbsp;&nbsp;​	首先，我们举个例子，比如序列	1 , 8 , 2 , 9 , 3 , 10 , 4 , 5

​&nbsp;&nbsp;​	我们可以知道，1,2,3,4,5和1,8,9,10都是他的单调递增子序列，其中1,2,3,4,5是最长的。最短的单调子序列长度为1，即仅仅包含某个元素自己。于是，***最长单调子序列必定存在，且长度至少为1***。

---

算法思路：

1.令S[1]S[2]S[3]...S[n]表示输入序列

2.令L[i] (1 <=  i <= n)表示以S[i]结束的最长单调子序列长度。即只需要考虑前i项的最长单调子序列长度即可。

3.总目标为max{L[1],L[2],...L[n]}

----

​&nbsp;&nbsp;举个例子：S = 1 ， 8 ， 2 ， 9 ， 3 ， 10

​&nbsp;&nbsp;那么L[6] = max { L [1] , L [2] , L[3] , L[4] , L[5] } + 1  (为什么呢，因为S[6]=10比S[1]...S[5]都大，因此如果前i项中最大的单调递增子序列长度为a，那么这六项的最大单调递增子序列长度为a+1)

​&nbsp;&nbsp;那么 ***L[5] = max{ L [1] , L [2] , L[3] , L[4]  } + 1 ?***  显然是不对的。因为S[5]=3，而S[4]=9,也就是说，该LCS的长度一定是前4项中最长的LCS长度加一。比如，我们可以发现L[4]=3,那么L[5] = 3并不等于L[4] + 1。因此，正确的 ***L[5] = max { L[1] , L[3] } + 1***  。也就是说，***L[i]取决于前 i 项中S[i] > S[j] 的 max{ L[j] }( 1 <= j < i)***

​&nbsp;&nbsp;于是我们可以得到如下递推式：

$$
L[i] = 
\begin{cases}
max \{L[j] \} + 1 && 若存在j使得1\le j < i 且S[j] < S[i] \\
1 && else
\end{cases}
$$

伪代码如下：

```
输入：序列S[1]S[2]S[3]...S[n]
输出：输入序列的最长单调递增子序列的长度len
1.	for i = 1 to n do
2.		L[i] = 1
3.		for j = 1 to i-1 do
4.			if S[j] < S[i] and L[j] >= L[i] then
5.				L[i] = L[j] + 1
6.	len = max{L[1],L[2],...,L[n]}
```

​&nbsp;&nbsp;但是，现在我们不是要找LCS的长度，而是要找一个最长的一个LCS，也就是说LCS是由那几个元素组成的，因此，我们需要一个标记函数来进行回溯解的组成。

​&nbsp;&nbsp;因此，令 ***标记函数P[i]表示这个最长单调子序列中在S[i]之前一项的位置***  也就是记录 L[i] 到底是由哪一个 L[j] 得到的，记录这个 j 的 值。如果 L[i] = 1，则取 P[i] = 0。

于是伪代码为：

```
1.	for i = 1 to n do
2.		L[i] = 1 , P[i] = 0
3.		for j = 1 to i-1 do
4.			if S[j] < S[i] and L[j] >= L[i] then
5.				L[i] = L[j] + 1 , P[i] = j
6.	len = max{L[1],L[2],...,L[n]} // 假设最大值在L[k]处取得
7.	i = 1
8.	j = k
9.	do
10.		T[i] = S[j] , i = i + 1 , j = P[j]
11.	until j = 0
12.	for i = L[k] down to 1
13.		print T[i]

```

![2](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/4.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Picture/2.png)
