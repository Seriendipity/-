$$
\color{red} 以下所有图片来自刘铎的PPT课件，仅供本人学习使用
$$

# 贪婪算法

​	在正式介绍贪婪算法之前，让我们来看这样一个例子。

> 问题描述：假定有面值分别为1元、5元、10元的三种硬币，各自都有足够多个。设计一种方法，用最少的硬币数给顾客支付制定金额。
>
> 假设：凑够19元。

​	对于上述问题，我们按照比较自然的想法，每次都找给顾客"尽可能大"的硬币。于是，对于19元的情况，我们的找零方案应该是：10元，5元，1元，1元，1元，1元。也就是最少用6个硬币能够完成上述回答。

​	那现在，我们来仔细看一下我们的想法：***在每次迭代中都选择不会超过还需要支付给顾客的金额的面值最大的硬币*** 。也就是说：我们每次都“贪婪”的选择当前“看起来”是最好的选择，然后我们期望这个当前最优解组合出来的贪婪解就是我们想要的最优解。

​	因此，贪婪算法可以分为以下几个步骤：

> 1.我们求解的过程是多步判断的过程
>
> 2.在每一步，我们总是选择目前看起来 ***“最好”***  的可行选择
>
> 3.进行局部最优选择，以期的得到全局最优解。

​	以上步骤是基于已经得到贪婪策略的步骤，如果未知贪婪策略，第一步应该是“猜测贪婪策略”，然后再按照该贪婪策略进行以上步骤。

## 一、找零问题

​	回看前文中的找零案例，我们来详细介绍一下贪婪算法求解的思路。

​	按照一个比较自然的想法，我们的贪婪思路是：***在每次迭代中都选择不会超过还需要支付给顾客的金额的面值最大的硬币*** 。（使用贪婪算法进行求解时，严格来说，我们需要对自己的想法来进行 ***正确性证明*** 。但事实上，正确性证明是很复杂的一件事情，至少对于我目前的水平来说，正确性证明是很难的。因此之后，我只给出几个简单的贪婪问题思路的正确性证明，有兴趣的小伙伴可以自行了解。）

​	***证明：对于面值为1元、5元、10元的情况，该算法可以得到最优解。***

> $$
> 设最优解为(x,y,z)。分别表示使用x个面值为10元的硬币，y个面值为5元的硬币以及z个面值为1元的硬币。 \qquad \qquad \qquad \qquad \quad 
> $$
>
> 
> $$
> 设由该贪婪算法得到的最优解为(x^\`,y^\`,z^\`),分别表示使用x^\`个面值为10元的硬币，y^\`个面值为5元的硬币以及z^\`个面值为1元的硬币。
> $$
>
> 
> $$
> 因此，我们只需要证明 x + y + z = x^\` + y^\` + z^\`即可证明贪婪解和最优解相同。\qquad \qquad \qquad \qquad \quad \qquad \qquad \qquad \qquad \quad
> $$
>
> $$
> 首先比较x和x^\`,考虑到贪婪算法的流程，一定有 x^\` \ge x (因为贪婪解从最大的10开始取，他的10元硬币的数量一定不低于最优解的个数)
> $$
>
> $$
> 那么如果 x^\` > x ，那么由10x + 5y + z = 10x^\` + 5y^\`+z^\`(因为找给顾客的钱是固定的，因此贪婪解和最优解总面值相同)，我们有
> $$
>
> $$
> 5y +z = 10(x^\` - x) + (5y^\` + z^\`) \ge 10
> $$
> 
> $$
> 那么就有三种可能：(1):y \ge 2，那么可以用2个5元硬币换一个10元硬币，硬币总数减1
> $$
> 
> $$
> (2):y=1,那么用1个5元硬币，5个1元硬币换一个10元硬币，硬币总数减少5
> $$
>
> $$
> (3):y=0,那么用10个1元硬币换1个10元硬币，硬币总数减少9。
> $$
>
> $$
> 因此我们可以看到，无论哪一种情况都和最优解的最优性产生了矛盾，于是x^\` > x不成立。同理可证明y^\`>y不成立，z^\`>z不成立
> $$
>
> > 解释一下三种可能：
> >
> > 假设现在 5y + z = 11;
> >
> > 那么如果 y>=2，最优解也就是找给顾客2个5元和1个1元，共3枚硬币；但我们可以把2个5元硬币换成1个10元的，这样就只需要找给顾客1个10元和1个1元，共2枚硬币。硬币总数少1。
> >
> > 如果y=1，最优解也就是找给顾客1个5元和6个1元，共7枚硬币；但是我们可以把1个5元和5个1元换成1个10元，这样就只需要找给顾客一个10元和1个1元，共2枚硬币。硬币总数少5
> >
> > 如果y=0，最优解也就是找给顾客11个1元，共11枚硬币。但是我们可以把10个1元换成1个10元，这样就只需要找给顾客一个10元和1个1元，共两枚硬币，硬币总数减少9。

​	上述我们证明了对于1元、5元、10元的硬币，该贪婪解是最优的。那么是否对于所有面值的硬币，该算法都是最优的呢？  答案是： ***不是！！！***

​	反例如下：如果现在有面值为1元、5元、7元、10元的四种硬币，要凑出19元。

> 收银员算法：1个10元，1个7元，2个1元，共四枚硬币。
>
> 最优解：2个7元，1个5元，共三枚硬币。

​	于是我们可以看到， ***贪婪算法并不一定保证能够得到最优解*** ，贪婪算法的正确性需要证明。

​	事实上，其他面值的找零问题可以通过动态规划来进行解决。后面会给出解释。

## 二、装载问题

> 问题描述：共有n个集装箱1,2,3，...，n。可以从中选择若干装上轮船，集装箱i的重量是w_i，轮船装载重量限制为C，如何选择使得船上集装箱总个数最多？

$$
问题抽象：即寻找集合U\subseteq \{1,2...n\},满足\sum_{u \in U} w(u) \le C ,求max|U|。
$$

​	我们从一个简单的分析入手，如果现在n=3，C=5，w_1 = 1 , w_2 = 2 , w_3 = 3。那么最优解：

> 物品1和2；或物品1和3；或物品2和3

​	因此，我们的贪婪策略： ***将集装箱按照从轻到重排序，轻者先装***，一定能保证装船上的集装箱总数最多。

下面简要证明上述贪婪策略是最优的。

$$
设S_G为贪婪解，包含k个集装箱，重量以递增顺序排列为w_{G,1},w_{G,2},...,w_{G,k}
$$

$$
设S_O为最优解，包含m个集装箱，重量以递增顺序排列为w_{O,1},w_{O,2},...,w_{O,m}
$$

$$
显然有k\le m (因为最优解的最优性决定最优解一定具有最多集装箱数)
$$

$$
定义S_G 和 S_O的相似度为 max{i|1\le i\le k,1 \le j \le k,对所有1\le j \le i,都有w_{G,j} = w_{O,j}}
$$

$$
若w_{G,1} \neq w_{O,1},定义S_G与S_O的相似度为0。
$$

$$
接下来比较贪婪解和（最像贪婪解的）最优解 
$$

$$
如果对于前i个箱子，贪婪解和最优解相同，对于第i个箱子，贪婪解和最优解不同，那么贪婪解的箱子重量一定轻于最优解。
$$

$$
既然如此，完全可以把最优解中的第i个箱子替换为贪婪解中的第i个箱子，并不会影响第i个箱子之后的箱子。
$$

$$
这样依次替换下去，由于 k \le m，那么如果k < m
$$

$$
由上述替换可知，我们对于最优解的前k-1个箱子都能替换为贪婪解中的箱子，那么对于后m-k个箱子
$$

$$
由于最优解仍然存在着箱子能放到船上，那么对于贪婪解而言，也一定能将该箱子放到船上，也就是贪婪解箱子数不会少于最优解。
$$

$$
因此 k = m 
于是，贪婪解和最像贪婪解的最优解完全相同，因此，上述算法正确性得证。
$$

$$
​	上述问题只考虑了箱子的数量，实际上，这是后续介绍的“背包问题”的特例，相当于各个物品的价值均等于重量。更一般的装载问题为：
$$

$$
寻找集合 U\subseteq \{ 1,2,...,n\},满足\sum_{u \in U}w(u) \le C ,求max\sum_{u\in U}w(u)
$$

​	对于上述问题，此前的贪婪策略并不能得到最优解。后续背包问题会给出解决方案。

## 三、活动选择问题

> 问题描述：由多名同学报名参加值班工作，每个同学有自己可能值班的时间段，但是由于客观原因限制，任何一个时刻，只能容纳一名值班同学。现在希望由尽可能多的同学来值班。

$$
问题抽象：给定n项活动的集合 S= \{1,2,...,n\},活动j开始时刻s_j,结束时刻f_j(f_j - s_j > 0)
$$

$$
\color{red}定义两个活动相容指的是他们没有时间上的重叠(大于0的重叠)
$$

$$
目标：所有活动的两两相容的最大子集。
$$

![1](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/3.%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/Pictures/1.png)

​	首先，我们要做的就是进行贪婪解的思路构建。我们几个比较自然的想法有如下：

> 【最早开始时刻优先】：按开始时刻s_j的升序考虑各个活动
>
> 【最早结束时刻优先】：按结束时刻f_j的升序考虑各个活动
>
> 【最短持续时间优先】：按持续时间的长度f_j - s_j 的升序考虑各个活动
>
> 【最少冲突数优先】：对于每个活动j，计算阈值冲突的活动数目c_j。按冲突活动数量的升序考虑各个活动。

​	由于是目前教学以及上课所用，我们直接列举了几种策略，排除了其中的若干个，最后一个一定是正确的思路。但是在自己实践的过程中，我们往往无法用这样的方式来进行判断。因为即使我们想出了10个思路，前九个都错误，也不能保证最后一个一定是正确的思路。

​	因此，在自己实践过程中，想反例往往是一个很重要的“技巧”与能力。这往往也没什么技巧，需要考经验等来进行边缘情况或者特殊情况验证。在接下来的过程中，我们也只是给出若干想法，排除掉一些反例之后，剩下的最后一个一定是可行方案，之后就不再赘述。

​	事实上，对于上述四种方案，【最早开始时刻优先】，【最短持续时间优先】，【最少冲突优先】我们都能举出反例，如下所示。

![2](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/3.%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/Pictures/2.png)

【最早时刻结束优先】伪代码如下：

```
1.对活动进行排序，使得f_1 <= f_2 <= ... <= f_n
2.  A = ∅
3.	for j = 1 to n do
4. 		if (活动j与A中所有活动都相容)
5.		A = A ∪ {j}
6.	return A
```

下面简要证明上述贪婪思路是最优的。

证明：

$$
假设i_1 , i_2,...,i_k是上述贪婪解依次选择的活动
$$

$$
假设j_1 , j_2,...,j_m是一个最优解，且具有满足i_1 = j_1,i_2 = j_2 ,...,i_r = j_r的最大可能非负整数r。(最像贪婪解的最优解)
$$

$$
(1):如果贪婪解只有i_1,i_2,...i_r,而最优解不仅有j_1,j_2,...j_r,还有j_{r+1},...j_m，那么贪婪解完全可以把最优解的j_{r+1}部分加入。对于后续的每一项都类似处理
$$

$$
(2):如果贪婪解中的i_{r+1}的活动结束时刻早于最优解中的j_{r+1},那么最优解的j_{r+1}完全可以用贪婪解的i_{r+1}替换，替换之后不会影响r+1以后的项
$$

$$
也就是说，替换之后的最优解依然是最优解，但是此时，贪婪解和最优解的前r+1项都是相同的，与r的最大性产生了矛盾。
$$

$$
因此，也就是说，贪婪解与最优解完全相同，上述算法思路是最优的。
$$

## 四、活动安排问题

> 问题描述：给定一系列活动，都有各自的开始时刻和结束时刻，每个活动必须在对应开始时间开始，需要的最少礼堂数是多少?

$$
问题抽象：给定一系列活动\{1,2,...,n\},活动j的开始时刻为s_j,结束时刻为f_j，其中f_j - s_i > 0 
$$

$$
这些活动必须安排在多个礼堂中，且不得有冲突，设计一个算法，计算达到此目的的最少礼堂数。
$$

​	我们首先举个栗子，看一下解有可能是什么样子的。比如我们有以下10个活动要安排。

![3](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/3.%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/Pictures/3.png)

那么我们能够得到的最优解为：

![4](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/3.%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/Pictures/10.png)

​	我们可以看到，需要三个礼堂，能够满足要求。那么我们能够到一个 ***关键性观察结论***。

> 观察结论：所需礼堂数大于等于同一时刻开始的活动数的最大值。
>
> 在上述10个活动中，我们可以看到同一时刻最多有3个活动同时在进行，因此，最终的礼堂数一定至少需要3个。

​	那么首先，我们要做的仍然是贪婪思路的构建。几个仍然比较自然的想法如下。

> 【最早开始时刻优先】：按开始时刻s_j的升序考虑各个活动
>
> 【最早结束时刻优先】：按结束时刻f_j的升序考虑各个活动
>
> 【最短持续时间优先】：按持续时间的长度f_j - s_j 的升序考虑各个活动
>
> 【最少冲突数优先】：对于每个活动j，计算阈值冲突的活动数目c_j。按冲突活动数量的升序考虑各个活动。

​	难道这个题和刚才的活动选择一样，选择【最早结束时刻优先】吗？答案是很遗憾的，不是。对于贪婪问题的求解，每一个题有自己的贪婪思路。即使是相同的题，我们稍微变换一下初始条件或者其他细微的变化，原贪婪解都可能不再适用，因此，针对每一个题，我们都应该独立的去思考他的贪婪思路。

​	对于上述四个贪婪思路，我们可以给出反例。

![5](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/3.%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/Pictures/4.png)

​	因此，对于该问题，我们选择【最早开始时刻优先】，下面给出伪代码

```
1. 对活动进行排序，使得s_1 <= s_2 <= ... <= s_n
2.	d = 0
3.	for j = 1 to n do
4.		if(活动j开始时有礼堂k处于空闲)
5.			将活动j安排在礼堂k
6.		else
7.			安排一个新的礼堂d + 1,并将活动j安排在该礼堂
8			d = d + 1
```

下面给出一个简要的证明贪婪思路的最优性。

证明：
$$
令d表示贪婪解安排的礼堂数目。
$$

$$
礼堂d被开放使用是因为需要安排的下一个活动(j)与其他d-1个礼堂中的活动皆有时间冲突
$$

$$
由于各个活动是按照开始时间进行排序的，因此其他d-1个礼堂中的与活动j有时间冲突的活动开始时间不晚于s_j
$$

$$
因此在时刻s_j + \epsilon 时，同时进行的活动至少有d个(其中\epsilon是一个非常小的正数值)
$$

$$
说明此时深度\ge d,即任何一个安排方案至少要用d个礼堂。 
$$

![6](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/3.%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/Pictures/5.png)

* 说明：黄色线为j活动开始时间，红色线为加上一个很小的正整数之后的时间。

## 五、最小延迟调度

> 问题描述：有多个任务，而只有一台任务处理机，各个任务必须串行。
> 
> $$
> 每个任务i需要使用t_i个单位时间进行处理，且有完成时限d_i(假定t_i和d_i都是正整数)
> $$
>
> $$
> 如果任务i在时刻s_i开始，那么他的完成时刻为f_i = s_i + t_i,他的延迟定义为l_i = max{0,f_i - d_i}
> $$
>
> $$
> 目标就是找到一种安排各个任务被处理的次序，使得他们的最大延迟maxl_i最小。
> $$

​	首先，我们举一个简单的例子来帮助我们理解一下这个题干。如果我们有如下6个任务，每个任务的完成所需时间，截止时间（ddl）都给出了。

​	我们可以将下述任务理解为，同时有若干个作业和ddl，完成每个作业所需时间都给出，我们如何安排做每个作业的时间，能够使得交作业时的总迟交时间最短。

![7](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/3.%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/Pictures/6.png)

​	我们仍然先想出几种贪婪策略，然后进行选择。我们比较自然的想法有以下几种。

> 【最短任务优先】：按任务所需时间的t_i升序来考虑各个任务
>
> 【紧急任务优先】：按任务的时限d_i的升序来考虑各个任务
>
> 【最小松弛时间优先】：按d_i - t_i的升序去考虑各个任务

​	对于上述三个想法，我们仍然可以采取举反例的方式去判断。

![8](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/3.%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/Pictures/7.png)

因此，我们选择第二种方案，【紧急任务优先】。

​	比如有如下3个任务，我们通过观察可以得到一个 **重要观察结论：最优方案中没有空闲时间。**

![9](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/3.%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/Pictures/8.png)

​	下面给出伪代码：

```
1.	对任务进行排序 使得 d_1 <= d_2 <= ... <= d_n
2.	f_0 = 0
3.	for i=1 to n
4.		f_i = f_{i-1} + t_i
```

​	下面证明上述贪婪策略是最优的。

证明：

$$
首先定义：任务i和任务j之间形成逆序：f(i) > f(j)且d_i < d_j(即d_i < d_j但是任务j在任务i之前被处理)
$$

$$
观察结果1：贪婪解中不存在逆序
$$

$$
观察结果2：如果一个(无空闲时间)的调度方案中有一对逆序，那么就一定存在两个相邻的任务互成逆序。
$$

$$
解释一下观察结果2：举个栗子，如果一组安排为10,5,6,7,8,9,4。我们可以看到，10和4形成逆序，存在一对逆序
$$

$$
那么10 和 5就形成了一对相邻的逆序。
$$

$$
有了上述两个观察结论之后，我们就两个观察结论开始进行证明。
$$

$$
假设任务i和任务j构成相邻逆序任务(d_i < d_j),那么交换任务i和任务j
$$

$$
首先。交换i和j对其他任务没有任何影响。交换i和j之后，i的延迟时间一定不会增加，j的延迟时间可能会增加
$$

$$
因为i的结束时间本来就比j提前，而却安排在j之后，现在将i和j交换之后，i的延迟时间一定不会增加。
$$

$$
下面来看j，交换之后，j的延迟时间一定不超过 t-d_j < t - d_i \le l_i , 也就是说总逆延迟时间不会增加
$$

$$
交换任务i和任务j之后，其他任务的逆序对个数不变，i和j之间的逆序关系消失，因此总逆序对个数严格减少。
$$

$$
于是，假设S^*是具有最少逆序数的最优解。那么如果S^*中不存在逆序数，他就是贪婪解。
$$

$$
如果S^*中存在逆序，那么他就一定存在相邻的逆序，记为i-j
$$

$$
对换任务i和任务j，由上述证明可知，并不会增加最大延迟，但是会严格减少逆序数，与S^*是最优解矛盾。
$$

$$
因此上述贪婪策略是最优的。
$$

## 六、MST

​	MST的问题描述就不再赘述了，感兴趣的小伙伴可以自行去查阅。

​	下面直接介绍为什么求解MST的算法是贪婪解。

>首先给出两个证明要用的定义：
>
>1.圈：形如a-b,b-c,c-d,...y-z,z-a的边序列
>
>2.割：顶点集的一个非空真子集S。相对应的割集D指的是端点包含且仅包含S中的一个点的边集。
>
>观察结论：任意圈（简单回路）与任意割的交集有偶数条边
>
>* 假定各边的权值不同
>
>> ***割性质*** ：设S是定带你集合V的一个真子集，e是S对应的割集D中最轻的边，则G的MST中必定包含e。
>>
>> 证明如下：
>> $$
>> 假设边e不在T^*中
>> $$
>>
>> $$
>> 将e加入到T^*中形成图G中的回路C，边e同时在回路C和割集D中，因此必定存在G的另一条边f也同时在回路C和割集D中
>> $$
>>
>> $$
>> 且边f的权值严格大于e的权值，T^`=T^*∪\{e\} - \{f\}也是G的一棵支撑树
>> $$
>>
>> $$
>> 由c_e < c_f可知cost(T^`) < cost(T^*)，于是产生矛盾
>> $$
>> 
>> ***圈性质*** ：设C是图G中的一个圈（简单回路），f是C中权重最大的边，G的MST一定不包含f。
>>
>> 证明如下：
>> 
>> $$
>> 假设f在T^*中
>> $$
>>
>> $$
>> 将f从T^*中删除将得到图G的一个割S，假设D是S对应的割集
>> $$
>>
>> $$
>> 边f同时在回路C和割集D中，因此必定还存在图G的另一条边e也同时在回路C和割集D中
>> $$
>>
>> $$
>> 边e的权值严格小于f的权值
>> $$
>>
>> $$
>> T^` = T^* ∪ \{e\} -\{f\}也是G的一棵MST
>> $$
>>
>> $$
>> 由c_e < c_f 可知，cost(T^`) < cost(T^*),产生矛盾
>> $$
>> 

由上述定义，我们可以对几种求解MST的方法进行贪婪解正确性证明：

>1.Prim算法：每次选择权值最小的点
>
>简要证明：
>
>$$
>初始化V_T = \{任意顶点\},之后使用归纳法，将割性质应用于V_T。于是在对应于V_T的割集中选择权值最小的边
>$$
>
>$$
>并向V_T中添加对应的新顶点u。
>$$
>
>```
>Algorithm Prim(G)
>输入：赋权连通图G=(V,E)
>输出：G的MST(之一)的边集合E_T
>1.	V_T = {v_0}
>2.	E_T = ∅
>3.	for i = 1 to |V|-1 do
>4.		选择V-V_T构成的割集中的最轻边
>5.		V_T = V_T ∪ {u*}
>6.		E_T = E_T ∪ {e*}
>7.	return E_T
>```
>
>````
>选择V-V_T构成的割集中的最轻边
>1.	for each v ∈ V do
>2.		cost[v] = ∞
>3.		prev[v] = NIL
>4.	cost[v_0] = 0
>5.	S = ∅
>6.	H = V
>7.	while H ≠ ∅
>8.		u = EXTRACT-MIN(H)
>9.		S = S ∪ {u}
>10.		for each z ∈ adj(u) - S do
>11.			if(cost[z] > w(u,z)) then
>12.				cost[z] = w(u,z)
>13.				pred[z] = u
>````
>
>2.Kruskal算法
>
>简要证明：
>
>$$
>以权值升序依次考虑各条边
>$$
>
>$$
>情形一：如果e添加到E_T中会形成一个圈，由圈性质，丢弃e
>$$
>
>$$
>情形二：否则，根据割性质，可以将e=(u,v)加入E_T,其中割集对应的顶点的集合S选择为u
>$$
>
>$$
>所在的连通分支中的顶点集合。
>$$
>
>```
>Algorithm Kruskal(G)
>输入：赋权连通图G=(V,E)
>输出：G的MST(之一)的边集合E_T
>1.	将所有边按照权值不减次序进行排序
>2.	E_T = ∅
>3.	for i = 1 to m 
>4.		记e_i的两端为u和v
>5.		if u 和 v 分属于(V,E_T)中不同的连通分支 then
>6.			E_T = E_T ∪{e_i}
>7.	return E_T
>```

## 七、单源最短道路SSSP

​	SSSP的问题描述也不再赘述了，有感兴趣的小伙伴可以自行去搜索了解。

> 首先介绍一个 **定理** ：
> 
> $$
> 设π：v_0,v_1,...,v_{k-1},v_k是图G中顶点v_0到v_k的一条最短道路，则V_0,v_1,...,v_{k-1}是v_0到v_{k-1}的最短道路(之一)
> $$
> 
> 证明：
>
> $$
> 若存在另一条从v_0 到 v_{k-1}的更短道路，v_0,u_1,...,v_k-1,则π^`:v_0,u_1,...,v_{k-1},v_k是从v_0到v_k的更短道路，产生矛盾。
> $$

​	假设目前到u的所有路径距离d(u)已经计算，而d(v)还没被计算。

>因此 d(v) = min{d(u) + l_{uv}}  其中u∈V，且uv相邻。

​	介绍一种求解SSSP的方法，dijkstra算法。

>dijkstra:
>
>1.维护一个已探索顶点的集合S
>
>2.记d(v)表示从图G中给定顶点s到v的最短道路树长度
>
>3.初始化S=∅，d(s) = 0
>
>4.不断选择使 π(v) = min {d(u) + l}达到最小值的未探索顶点v，将v加入S，并令d(v) = π(v)

```
1.	for each v ∈ V do
2.		d[v] = ∞
3.		pred[v] = NIL
4.	d[s] = 0
5.	S = ∅
6.	H = V
7.	while H ≠ ∅ do
8.		u = EXTRACT-MIN(H)
9.		S = S ∪ {u}
10.		for each z ∈ adj(u) - S do
11.			if d[z] > d[u] + w(u,z) then
12.				d[z] = d[u] + w(u,z)
13.				pred[z] = u
```

