# 算法

​	算法这一个词或许我们都不陌生，但究竟什么才是算法呢？

​	我去买了一本书；我用10元买了一本书。这些都算得上是算法吗？（不算）

> 以我看来，算法就是用来解决某种问题时的一种策略。

> 其具有***有限性、确定性、有效性、输入和输出***这五个特点。

​	那为什么算法要具有上述特征呢？首先，算法是用来解决某种问题的策略，如果因此算法一定会有输入和输出，根据问题的不同情境下给出不同的输出。在解决问题的时候，我们往往想要的是在最快的时间内给出能够让我们 ***“接受”*** 的一个 ***“解”***。

​	举个栗子，给定一个输入即让他算从1加到100的和，他给出输出需要100年的时间甚至无限长（时间爆炸，如10的若干指数次）的时间才给出结果，那么我们通常不认为这是一个有效的算法。因为这个解所要求的东西不是我们所能接受的，算法是用机器来为人类进行求解的，如果这样的话，为什么不手算呢，手算的时间都比机器算出来的时间短得多。因此，算法一定要具有有限性和有效性，才能保证我们能够接受。此外，算法还必须保证正确性，这里的正确性指的是每一步必须有严格的约定，不能说是概念上的 ***”大约是“*** ，***”差不多“*** 这样类型的。应该还有理论证明的 ***（尽管算法正确性证明可能对于自身要求性很高，至少在我自己现有的水平阶段是没办法进行正确性证明的）***。

​	那么什么样的算法才能算是一个好算法呢？应该具有简洁、高效、自明性的特点。

​	

# 算法的时间复杂度分析

* 1.函数的增长率：以下都假设f和g是在非负实数集上取值恒为正的增函数

> O记号表示：函数f的增长率的上界，即f的增长率不会超过O
>
> > $$
> > 若存在正的常数c和n_0，使得对于一切n\ge n_0,有0 \le f(n) \le cg(n)成立,那么我们就称f(n) 是O(g(n))\\
> > 的，记作f(n) \in O(g(n))
> > $$
> >
> > 
>
> Ω记号表示：函数f的增长率下界，即f的增长率不会低于Ω
>
> > $$
> > 若存在正的常数c和n_0，使得对于一切n\ge n_0,有0 \le cg(n) \le f(n)成立,那么我们就称f(n) 是Ω(g(n))\\
> > 的，记作f(n) \in Ω(g(n))
> > $$
> >
> > 
>
> θ记号表示：函数f的增长率和θ的增长率 ***同阶***
>
> > $$
> > 若存在正的常数c_1,c_2和n_0，使得对于一切n\ge n_0,有c_1g(n) \le f(n) \le c_2g(n)成立,那么我们就称f(n)\\ 是\Theta(g(n))的，记作f(n) \in \Theta(g(n))
> > $$
> >
> > 

举个栗子：

​	我们称f是O（g）的，通常来说，我们指的是，从某一个点开始之后，f的值不会超过（可以等于）g的常数倍（某一个常数即可）。



​	我们称f是Ω（g）的，通常来说，我们指的是，从某一个点开始之后，f的值不会低于（可以等于）g的常数倍（某一个常数即可）。



​	我们称θ是（g）的，通常来说，我们指的是，从某一个点开始之后，f的值被两条线夹在中间，可以相等。





下面说一下我自己是如何判断两个函数之间到底存在着哪种关系，我采用求极限的方式来进行比较。

举个栗子：
$$
比如有两个函数10n和2log_2(n),我们来比较他们的关系，对他们做极限。\\
\lim_{n-> +\infty} \frac{10n}{2log_2(n)} = \lim_{n-> +\infty} \frac{n}{log_2(n)} = +\infty
$$

> 如果求极限之后，比值是无穷大，说明分子的增长速率要比分母要大得多，即如果分子用函数f表示，分母用函数g表示，那么就有

$$
g \in O(f) \quad f \in Ω(g)
$$

> 如果求极限之后，比值是0，那么说明分子的增长速率比分母慢得多，那么就有

$$
f \in O(g) \quad g \in Ω(f)
$$

> 如果求极限之后，比值是一个常数，那么说明分子和分母的增长速率相同，那么就有

$$
f \in \Theta(g) \quad g \in \Theta(f)
$$

* 下面介绍几种性质（对于Ω，θ也成立，这里只举O）

$$
1.若f是O(g)的，g是O(h)的，那么f是O(h)的 \\
2.若m是一个正常数，f是O(g)的，那么m*f 也是O(g)的 \\
3.若f_1是O(g_1)的，f_2是O(g_2)的，那么有f_1 * f_2 是O(g_1 * g_2)的\\
4.若f_1是O(g_1)的，f_2是O(g_2)的，那么有f_1 + f_2 是O(g_1 + g_2)的\\
5.如果f_1和f_2都是O(g)的，那么有f_1 + f_2是O(g)的
$$



> 算法的总体效率由增长率最大的部分决定。

​	举个栗子：
$$
f(n) = 100log_2(n) + log_2^2(n) + 3n + 58 n^2 + \frac{1}{100}n^3
$$
通过上面的计算，我们可以知道，f(n)是O（n^3)的，仅由具有最大增长率的部分决定，其他部分不会产生影响。
