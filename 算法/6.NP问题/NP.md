
# NP问题

# 一、NP理论

​	在讨论NP理论之前，首先介绍一下**问题**的定义。

> **易解性**：如果存在关于输入大小多项式时间算法，那么我们认为该问题是易解的。
>
> **难解性**：如果不存在关于输入大小多项式时间算法。

因此，对于一个问题，我们迫切知道问题的类型。以多项式时间作为分界线，将问题进行分类，由此引申出了NP理论。

在引出NP理论之前，首先定义**问题的类型**。我们认为，很多问题都分为了两个版本

> **最优化问题**：构造一个解，将某个函数最大化或者最小化
>
> **判定性问题**：对于输入的问题，回答YES或者NO

---

举个栗子，如哈密顿回路问题：

最优化问题为：给定一个赋权图，求总权值最小的哈密顿回路

判定性问题为：给定一个赋权图一个整数k，是否存在总权值不超过k的哈密顿回路

---

​	通过上面的例子，我们可以发现，**如果我们能够求解最优化问题，那么我们就能轻松解决判定性问题**。比如，假设我们已经有了求解哈密顿回路的最优化的解决方案，得到的赋权图的最优解为M，现在，给定一个整数k，要判断是否存在总权值不超过k的哈密顿回路，只需要用k去和M进行比较即可。如果k小于M，那么返回NO，否则返回YES即可。

​	反之，**如果我们能够求解判定性问题，那么我们就能够求解最优化问题**。仍然以哈密顿回路为例，比如赋权图中权重最大的边为 w_max,共有n个点，那么该赋权图的权值上界为n\*w_max.因为我们有判定性问题的求解方案，那么我们可以采用二分的方式来逼近最优解。比如，首先问，是否存在权值不超过 （n\*w_max）/2的哈密顿回路。如果YES，那么继续问是否存在权值不超过（n*w_max）/2/2的哈密顿回路，如果NO，那么询问是否存在权值不超过3\*(n\*w_max)/8的哈密顿回路，以此类推，以二分的形式求得最优解。

---

​	通过上述分析，我们不难发现，如果能有效的解决其中的一个问题，那么我们也能够有效的解决另一个问题。这就是**可归约性**。简单而言就是，我们可以把当前问题的求解思路转化为求解另一个问题的求解，然后进行变换得到对应解。

​	举个栗子，我们在前面动态规划的时候曾经说过，LCS和SCS存在相互转换公式，那么对于SCS的求解问题，就可以归约为求解LCS的问题，然后再转换结果得到SCS问题的求解。

---

​	知道了可归约性之后，我们的思路一下就变得开阔起来，现在，我们不只希望能够解决某一类问题。我们希望，**如果某一类问题是易解的，即能够在多项式时间内求解，那么还有哪一类问题也能够在多项式时间内求解？**

​	因此引入**多项式归约**。如果问题X可以使用多项式次数个标准计算步骤，以及对求解问题Y的**预言**的多项式次调用，我们就称问题X是多项式归约到问题Y的。记作：

$$
X \le_P Y
$$

​	简单而言，就是对于问题X的求解，可以用多项式次的对Y的求解来做到。如对于SCS的求解，我们就可以通过一次的对LCS的求解来得到；对点独立集的求解，我们就可以通过对点覆盖集的求解来得到……

> 下面解释一下为什么是预言：

​	预言翻译自（oracle），假设我们有一个黑盒子（一个算法），可以帮助我们解决问题Y的实例，如果我们每次输入Y的一个实例，那么在单次操作中，黑盒将返回正确的回答。相当于我们站在一个上帝视角，对于一个实例，我们不去管内部如何实现的，只需要给定一个实例，输出一个结果。如同 ”预言“ 一样。

> 那么，对于X多项式时间内归约到Y，我们可以做出如下解释：

​	假设现在有一个X的实例A，我们将实例A通过f（A）转换为M个Y的实例。其中M是多项式个。然后对这M个Y的实例，依次使用求解Y的算法，得到M个Y的解S。如果解S中存在某个实例无解，那么X的实例A无解，否则输出一个A的实例的解S（由M个Y的解组成）。那么，这个由求解Y的算法就转换为了求解X的算法。

![image-20240624221001873](https://github.com/Seriendipity/Learning-Note/blob/main/%E7%AE%97%E6%B3%95/6.NP%E9%97%AE%E9%A2%98/1.png)

下面介绍一下多项式时间归约的性质：

$$
1.自反性：X \le_P X.\qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad 
\qquad \qquad \qquad \qquad \quad \quad
$$

$$
2.传递性：若X \le_P Y 且Y \le_P Z，那么有X \le_pZ.\qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad
$$

$$
3.X\le_P Y.若Y能在多项式时间内求解，则X也能够在多项式时间内求解.若X不能在多项式时间内求解，则Y也不能在多项式时间内求解。\qquad \quad
$$

$$
4.若X\le_P Y,Y\le_P X,则X，Y称为多项式等价X \equiv_P Y，如果一方能在多项式时间内求解，那么另一方也能够在多项式时间内求解。\qquad \qquad .
$$

$$
下面给一个简要的证明梗概：
$$
1.证明：X \le_P X就相当于没有进行任何归约，用自己的方法来求解自己。\qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad 
$$

$$
2.证明：X \le_p Y 说明 X可以转换为f(I)个对问题Y的求解，Y\le_p Z 说明每个Y问题可以转换为对g(I)个问题Z的求解
$$

$$
因此，每个X可以转换为对g(f(I))个问题Z的求解。而由多项式的性质，多项式的多项式还是多项式，因此X\le_P Z.
$$

---

因此，基本求解思路为，建立等价关系，进行等价类划分，寻找代表元，对代表元进行研究，进而对同一个等价类中的问题进行归约，解决一批问题。

下面给出几个示例：

## Eg1:

> **点独立集（INDEPENDENT-SET）问题**：
> 
> $$
> 给定简单图G=(V,E)以及一个整数k，是否存在顶点的子集S\subset V,使得|S|\ge k,且图中任一条边都至多只有一个端点在S中。
> $$
> 
> **顶点覆盖（VERTEX-COVER）问题**：
> 
> $$
> 给定简单图G=(V,E)以及一个整数k，是否存在顶点的子集S\subset V，使得|S|\le k,且图中任一条边都至少有一个端点在S中
> $$

上述两个问题是多项式等价的。

$$
断言：VERTEX-COVER \equiv_P INDEPENDENT-SET
$$

**S是点独立集当且仅当V-S是点覆盖集**。证明就不再赘述了，有感兴趣的小伙伴可参考离散数学中的证明。

## Eg2:

> **k-团（k-clique）**：是个完全图K_k.即有k个顶点，他们之间有k(k-1)/2条边。
>
> **k-团问题（CLIQUE）**：给定图G和值k，判断图G中是否含有k-团作为子图。

$$
断言 CLIQUE \equiv_P INDEPENDENT-SET
$$

## Eg3:

> **集合覆盖问题（SET-COVER）**：给定一个基础集合U，他的一些子集S_1,S_2,...S_m以及整数k，是否可以从中选择至多k个子集，使得他们的并集恰好是U。

$$
断言：VERTEX-COVER \le_P SET-COVER
$$

---

下面介绍**P类问题**和**NP类问题**

> **P类问题**：所有多项式时间可解的判定问题组成的问题类称为P类。即可以在O（p（n））时间求解的一类**判定性问题**。其中p（n）是关于输入规模n的多项式。即**有多项式时间算法的判定性问题**
>
> **NP类问题：**由多项式时间内**可验证**的判定性问题组成。若一个判定性问题存在多项式时间验证器，则该问题属于NP类。粗略的讲，如果我们以某种方式得到了该问题的一个实例，我们可以在多项式的时间内对该候选解的正确性进行验证。**事实上，NP代表非确定多项式时间。**

---

简单而言，如果能在多项式时间内求解一个问题，那么就是**P类问题**。如果能在多项式时间内验证一个解是否是正确的，那么这个问题就是**NP类问题**。这是一个，至少看起来是一个比能够在多项式时间内找到正确解宽松的多的条件。

***！！！注意！！！***：NP并非意为not P。

$$
断言： P \subset NP.
$$

至于P是否等于NP，目前尚无定论。P=NP关系着大量问题是否存在多项式时间内能解的快速算法。

# 二、NP完全理论

> $$
> NP困难：如果问题\Pi 满足对于所有\Pi' \in NP都有\Pi' \le_P \Pi，则\Pi称作在多项式规约下是NP困难的。不要求\Pi \in NP
> $$
>
> $$
> NP完全：如果问题\Pi是NP困难的，且\Pi \in NP，则称他是NP完全的。这是NP类中最困难的问题，在多项式归约意义下的一个等价类。
> $$

**NPC**:Y是一个NP问题，且对于任意NP问题X，都有X多项式归约到Y。

**如果一个NPC问题有一个多项式时间算法，那么NP中的每个问题都有多项式时间算法**

> 定理：假设Y是一个NPC问题，则Y存在多项式时间算法，当且仅当P=NP

---

> 如果X是一个NPC问题，Y是一个NP问题，且X多项式归约到Y，则Y是NPC问题。
